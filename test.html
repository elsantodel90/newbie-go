<!doctype html>

<html lang="es">
<head>
  <meta charset="utf-8">

  <title>Ejemplo de atari-go?</title>
  <meta name="description" content="Ejemplo">
  <meta name="author" content="elsantodel90.tk">

  <!--
  <link rel="stylesheet" href="css/styles.css?v=1.0">
   !-->
   
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <script src="js/glift_1_1_2.min.js"></script>
  
  <style type="text/css">
      #gliftDiv {
          width:500px;
          height:500px;
      }
      #boardText{
          font-family : courier;
      }
  </style>
  <div>
      <h1>Ejemplo de atari-go</h1>
  </div>
  <div id="boardText">
  </div>
  <div id="gliftDiv">
  </div>

  <script>

var BOARD_SIZE = 9;
var BOARD_X_START = 40;
var BOARD_Y_START = 40;
var BOARD_X_CELL = 52;
var BOARD_Y_CELL = 52;

var EMPTY = 0;
var BLACK = 1;
var WHITE = 2;
var KOBAN = 3;

var currentPlayer = BLACK;
var globalBoard = []; 
for (var i = 0; i < BOARD_SIZE; i++) {
    globalBoard.push([]);
    for (var j = 0; j < BOARD_SIZE; j++)
        globalBoard[i].push(EMPTY);
}

function boardCopy(boardToCopy) {
    var ret = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        ret.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            ret[i].push(boardToCopy[i][j]);
    }
    return ret;
}

var boardHistory = [boardCopy(globalBoard)];
var moveHistory = [];
var humanPlayer = BLACK;


function toLetter(index) {
    return String.fromCharCode('a'.charCodeAt(0) + index);
}

function getSgfString() {
    var ret = "(;SZ[" + BOARD_SIZE + "]";
    for (var i = 0; i < moveHistory.length; i++) {
        var move = moveHistory[i];
        var colorLetter;
        if (move.color == WHITE)
            colorLetter = 'W';
        else if (move.color == BLACK)
            colorLetter = 'B';
        else
            throw "Assertion error: Invalid COLOR in move " + i + " = " + move;
        ret += ";" + colorLetter + "[" + toLetter(move.x) + toLetter(move.y) + "]";
    }
    ret += ")";
    return ret;
}

var gliftWidget = null;

function drawBoard() {
    document.getElementById("boardText").innerHTML = getBoardHTML(globalBoard);
    if (gliftWidget !== null)
        gliftWidget.destroy();
    gliftWidget = glift.create({
      divId: "gliftDiv",
      sgfDefaults : {
        sgfString : getSgfString(),
        boardRegion : glift.enums.boardRegions.ALL,
        initialPosition : moveHistory.length,
        widgetType : glift.WidgetType.GAME_VIEWER,
        uiComponents : ["BOARD"]
      },
      display: {
        theme: 'DEPTH',
        goBoardBackground: 'images/purty_wood.png'
      }
    });
}

function cellToChar(cell) {
    if (cell == EMPTY)
        return '.';
    else if (cell == BLACK)
        return 'B';
    else if (cell == WHITE)
        return 'W';
    else if (cell == KOBAN)
        return 'K';
    else
        throw "Assertion: contenido de intersección inválida. " + cell;
}

function getBoardHTML(board) {
    var ret = "";
    for (var i = 0; i < BOARD_SIZE; i++) {
        for (var j = 0; j < BOARD_SIZE; j++)
            ret += cellToChar(board[j][i]);
        ret += "<br>";
    }
    return ret;
}

function alertUser(message) {
    alert(message);
}

var dx = [0,0,1,-1];
var dy = [1,-1,0,0];

var dfsStatus;
var dfsColor;
var dfsMark;
var dfsBoard;

function clearDfsStatus() {
    dfsStatus = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        dfsStatus.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            dfsStatus[i].push(0);
    }
}

function inRange(x,y) {
    return 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE;
}

function libertyDfs(x,y) {
    dfsStatus[x][y] = dfsMark;
    var liberties = 0;
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && dfsStatus[nx][ny] != dfsMark) {
            if (dfsBoard[nx][ny] == EMPTY)
            {
                liberties++;
                dfsStatus[nx][ny] = dfsMark;
            }
            else if (dfsBoard[nx][ny] == dfsColor)
                liberties += libertyDfs(nx,ny);
        }
    }
    return liberties;
}

function otherPlayer(player) {
    if (player === undefined)
        throw "Assertion: hay que pasarle parametro a otherPlayer!";
    if (player == BLACK)
        return WHITE;
    else if (player == WHITE)
        return BLACK;
    else
        throw "Assertion: el jugador solo puede ser blanco o negro! Es en su lugar " + player;
}

function move(board, player, x,y) {
    if (!inRange(x,y))
        return {"status" : "OUT_OF_RANGE"};
    if (board[x][y] == KOBAN)
        return {"status" :  "No se puede jugar en esa intersección debido a la regla del Ko: se repetiría la posición del tablero."};
    if (board[x][y] != EMPTY)
        return {"status" : "Solamente se puede jugar en una intersección vacía del tablero."};
    
    board = boardCopy(board);
    
    // Clear the koban
    var kobanX = null, kobanY = null;
    for (var i = 0; i < BOARD_SIZE; i++)
    for (var j = 0; j < BOARD_SIZE; j++)
        if (board[i][j] == KOBAN)
        {
            board[i][j] = EMPTY;
            kobanX = i;
            kobanY = j;
        }
    
    clearDfsStatus();
    
    var dirAtari = [false, false, false, false];
    var atari = [false, false, false, false];
    var playerSafe = false;
    
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && board[nx][ny] == EMPTY)
            playerSafe = true;
        if (inRange(nx,ny) && dfsStatus[nx][ny] == 0 && board[nx][ny] != EMPTY) {
            dfsColor = board[nx][ny];
            dfsMark = dir+1;
            dfsBoard = board;
            if (libertyDfs(nx,ny) == 1) {
                dirAtari[dir] = true;
                atari[dfsColor] = true;
            }
            else if (dfsColor == player)
                playerSafe = true;
        }
    }
    
    if (!playerSafe && !atari[otherPlayer(player)])
        return {"status" : "No se puede jugar en esa intersección debido a la regla de no suicidio: la jugada crearía un grupo propio sin libertades."};
    
    // The move is valid
    
    board[x][y] = player;
    
    var captures = 0;
    var captureX, captureY;
    if (atari[otherPlayer(player)])
    {
        for (var i = 0; i < BOARD_SIZE; i++)
        for (var j = 0; j < BOARD_SIZE; j++)
            if (dfsStatus[i][j] > 0 && board[i][j] == otherPlayer(player) && dirAtari[dfsStatus[i][j] - 1])
            {
                board[i][j] = EMPTY;
                captureX = i;
                captureY = j;
                captures++;
            }
    }

    if (captures == 1) {
        // Check for lone stone
        var loneStone = true;
        for (var dir = 0; dir < 4; dir++) {
            var nx = x + dx[dir];
            var ny = y + dy[dir];
            if (inRange(nx,ny) && (nx != captureX || ny != captureY) && (board[nx][ny] != otherPlayer(player)))
                loneStone = false;
        }
        if (loneStone)
            board[captureX][captureY] = KOBAN;
    }
    
    return {"status" : "OK", "board" : board, "captures" : captures};
}

function showMessageFunction(humanWins) {
    if (humanWins)
        return function() {
            alertUser("¡VICTORIA!");
        };
    else
        return function() {
            alertUser("DERROTA :(");
        };
}

function makeMove(x,y) {
    var moveResult = move(globalBoard, currentPlayer, x,y);
    if (moveResult["status"] == "OK") {
        globalBoard = moveResult["board"];
        boardHistory.push(boardCopy(globalBoard));
        moveHistory.push({"color" : currentPlayer, "x" : x, "y" : y});
        if (moveResult["captures"] > 0)
            setTimeout(showMessageFunction(currentPlayer == humanPlayer) , 100);
        currentPlayer = otherPlayer(currentPlayer);
        if (currentPlayer != humanPlayer)
            setTimeout(makeAIMove, 100);
    }
    else if (moveResult["status"] != "OUT_OF_RANGE")
        alertUser(moveResult["status"]);
}

var gliftDiv = document.getElementById("gliftDiv");

function getAtariGoAIMove(board, player) {
    var validMove = null;
    var options = [];
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) {
        var moveResult = move(board, player, i,j);
        var moveDescription = {"x" : i, "y" : j, "newBoard" : moveResult["board"]};
        if (moveResult["status"] == "OK" && moveResult["captures"] > 0)
            return [moveDescription];
        if (moveResult["status"] == "OK") {
            if (validMove === null)
                validMove = moveDescription;
            var badMove = false;
            for (var i2 =0; i2< BOARD_SIZE; i2++)
            for (var j2 =0; j2< BOARD_SIZE; j2++) {
                var moveResult2 = move(moveResult["board"], otherPlayer(player), i2,j2);
                if (moveResult2["status"] == "OK" && moveResult2["captures"] > 0)
                {
                    badMove = true;
                    i2 = BOARD_SIZE;
                    j2 = BOARD_SIZE;
                }
            }
            if (!badMove)
                options.push(moveDescription);
        }
    }
    if (options.length > 0)
        return options;
    else
        return [validMove];
}

function makeAIMove() {
    var options = getAtariGoAIMove(globalBoard, currentPlayer);
    var aiMove = options[Math.floor(Math.random()*options.length)];
    makeMove(aiMove.x,aiMove.y);
    drawBoard();
}

function fooClick(event) {
    if (currentPlayer == humanPlayer) {
        var x = event.clientX - gliftDiv.offsetLeft;
        var y = event.clientY - gliftDiv.offsetTop;
        var moveX = Math.round((x - BOARD_X_START) / BOARD_X_CELL);
        var moveY = Math.round((y - BOARD_Y_START) / BOARD_Y_CELL);
        makeMove(moveX, moveY);
        drawBoard();
    }
}

gliftDiv.addEventListener("click", fooClick);
drawBoard();

  </script>
  
</body>
</html>
