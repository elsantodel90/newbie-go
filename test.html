<!doctype html>

<html lang="es">
<head>
  <meta charset="utf-8">

  <title>Ejemplo de atari-go?</title>
  <meta name="description" content="Ejemplo">
  <meta name="author" content="elsantodel90.tk">

  <!--
  <link rel="stylesheet" href="css/styles.css?v=1.0">
   !-->
   
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <script src="js/glift_1_1_2.min.js"></script>
  
  <style type="text/css">
      #gliftDiv {
          width:500px;
          height:500px;
      }
      #boardText{
          font-family : courier;
      }
  </style>
  <div>
      <h1>Ejemplo de atari-go</h1>
  </div>
  <div id="boardText">
  </div>
  <div id="gliftDiv">
  </div>

  <script>

var BOARD_SIZE = 9;
var BOARD_X_START = 40;
var BOARD_Y_START = 40;
var BOARD_X_CELL = 52;
var BOARD_Y_CELL = 52;

var EMPTY = 0;
var BLACK = 1;
var WHITE = 2;
var KOBAN = 3;

var currentPlayer = BLACK;
var globalBoard = []; 
for (var i = 0; i < BOARD_SIZE; i++) {
    globalBoard.push([]);
    for (var j = 0; j < BOARD_SIZE; j++)
        globalBoard[i].push(EMPTY);
}

function boardCopy(boardToCopy) {
    var ret = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        ret.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            ret[i].push(boardToCopy[i][j]);
    }
    return ret;
}

var boardHistory = [boardCopy(globalBoard)];
var moveHistory = [];
var humanPlayer = BLACK;


function toLetter(index) {
    return String.fromCharCode('a'.charCodeAt(0) + index);
}

function getSgfString() {
    var ret = "(;SZ[" + BOARD_SIZE + "]";
    for (var i = 0; i < moveHistory.length; i++) {
        var move = moveHistory[i];
        var colorLetter;
        if (move.color == WHITE)
            colorLetter = 'W';
        else if (move.color == BLACK)
            colorLetter = 'B';
        else
            throw "Assertion error: Invalid COLOR in move " + i + " = " + move;
        ret += ";" + colorLetter + "[" + toLetter(move.x) + toLetter(move.y) + "]";
    }
    ret += ")";
    return ret;
}

var gliftWidget = null;

function drawBoard() {
    document.getElementById("boardText").innerHTML = getBoardHTML(globalBoard);
    if (gliftWidget !== null)
        gliftWidget.destroy();
    gliftWidget = glift.create({
      divId: "gliftDiv",
      sgfDefaults : {
        sgfString : getSgfString(),
        boardRegion : glift.enums.boardRegions.ALL,
        initialPosition : moveHistory.length,
        widgetType : glift.WidgetType.GAME_VIEWER,
        uiComponents : ["BOARD"]
      },
      display: {
        theme: 'DEPTH',
        goBoardBackground: 'images/purty_wood.png'
      }
    });
}

function cellToChar(cell) {
    if (cell == EMPTY)
        return '.';
    else if (cell == BLACK)
        return 'B';
    else if (cell == WHITE)
        return 'W';
    else if (cell == KOBAN)
        return 'K';
    else
        throw "Assertion: contenido de intersección inválida. " + cell;
}

function getBoardHTML(board) {
    var ret = "";
    for (var i = 0; i < BOARD_SIZE; i++) {
        for (var j = 0; j < BOARD_SIZE; j++)
            ret += cellToChar(board[j][i]);
        ret += "<br>";
    }
    return ret;
}

function alertUser(message) {
    alert(message);
}

var dx = [0,0,1,-1];
var dy = [1,-1,0,0];

var dfsStatus;
var dfsColor;
var dfsMark;
var dfsBoard;

function clearDfsStatus() {
    dfsStatus = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        dfsStatus.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            dfsStatus[i].push(0);
    }
}

function inRange(x,y) {
    return 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE;
}

function libertyDfs(x,y) {
    dfsStatus[x][y] = dfsMark;
    var liberties = 0;
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && dfsStatus[nx][ny] != dfsMark) {
            if (dfsBoard[nx][ny] == EMPTY)
            {
                liberties++;
                dfsStatus[nx][ny] = dfsMark;
            }
            else if (dfsBoard[nx][ny] == dfsColor)
                liberties += libertyDfs(nx,ny);
        }
    }
    return liberties;
}

function otherPlayer(player) {
    if (player === undefined)
        throw "Assertion: hay que pasarle parametro a otherPlayer!";
    if (player == BLACK)
        return WHITE;
    else if (player == WHITE)
        return BLACK;
    else
        throw "Assertion: el jugador solo puede ser blanco o negro! Es en su lugar " + player;
}

function move(board, player, x,y) {
    if (!inRange(x,y))
        return {"status" : "OUT_OF_RANGE"};
    if (board[x][y] == KOBAN)
        return {"status" :  "No se puede jugar en esa intersección debido a la regla del Ko: se repetiría la posición del tablero."};
    if (board[x][y] != EMPTY)
        return {"status" : "Solamente se puede jugar en una intersección vacía del tablero."};
    
    // Clear the koban
    var kobanX = null, kobanY = null;
    for (var i = 0; i < BOARD_SIZE; i++)
    for (var j = 0; j < BOARD_SIZE; j++)
        if (board[i][j] == KOBAN)
        {
            board[i][j] = EMPTY;
            kobanX = i;
            kobanY = j;
        }
    
    clearDfsStatus();
    
    var dirAtari = [false, false, false, false];
    var atari = [false, false, false, false];
    var playerSafe = false;
    
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && board[nx][ny] == EMPTY)
            playerSafe = true;
        if (inRange(nx,ny) && dfsStatus[nx][ny] == 0 && board[nx][ny] != EMPTY) {
            dfsColor = board[nx][ny];
            dfsMark = dir+1;
            dfsBoard = board;
            if (libertyDfs(nx,ny) == 1) {
                dirAtari[dir] = true;
                atari[dfsColor] = true;
            }
            else if (dfsColor == player)
                playerSafe = true;
        }
    }
    
    if (!playerSafe && !atari[otherPlayer(player)])
    {
        if (kobanX !== null)
            board[kobanX][kobanY] = KOBAN;
        return {"status" : "No se puede jugar en esa intersección debido a la regla de no suicidio: la jugada crearía un grupo propio sin libertades."};
    }
    
    // The move is valid
    
    board[x][y] = player;
    
    var captures = 0;
    var captureX, captureY;
    if (atari[otherPlayer(player)])
    {
        for (var i = 0; i < BOARD_SIZE; i++)
        for (var j = 0; j < BOARD_SIZE; j++)
            if (dfsStatus[i][j] > 0 && board[i][j] == otherPlayer(player) && dirAtari[dfsStatus[i][j] - 1])
            {
                board[i][j] = EMPTY;
                captureX = i;
                captureY = j;
                captures++;
            }
    }

    if (captures == 1) {
        // Check for lone stone
        var loneStone = true;
        for (var dir = 0; dir < 4; dir++) {
            var nx = x + dx[dir];
            var ny = y + dy[dir];
            if (inRange(nx,ny) && (nx != captureX || ny != captureY) && (board[nx][ny] != otherPlayer(player)))
                loneStone = false;
        }
        if (loneStone)
            board[captureX][captureY] = KOBAN;
    }
    
    return {"status" : "OK", "board" : board, "captures" : captures};
}

function showMessageFunction(humanWins) {
    if (humanWins)
        return function() {
            alertUser("¡VICTORIA!");
        };
    else
        return function() {
            alertUser("DERROTA :(");
        };
}

function makeMove(x,y) {
    var moveResult = move(globalBoard, currentPlayer, x,y);
    if (moveResult["status"] == "OK") {
        boardHistory.push(boardCopy(globalBoard));
        moveHistory.push({"color" : currentPlayer, "x" : x, "y" : y});
        if (moveResult["captures"] > 0)
            setTimeout(showMessageFunction(currentPlayer == humanPlayer) , 100);
        currentPlayer = otherPlayer(currentPlayer);
        if (currentPlayer != humanPlayer)
            setTimeout(makeAIMove, 100);
    }
    else if (moveResult["status"] != "OUT_OF_RANGE")
        alertUser(moveResult["status"]);
}

var gliftDiv = document.getElementById("gliftDiv");

function playerSign(player) {
    if (player == BLACK)
        return 1.0;
    else
        return -1.0;
}

var MONTECARLO_PLAYOUTS = 4000;

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

var allBoardMoves = [];
for (var i =0; i< BOARD_SIZE; i++)
for (var j =0; j< BOARD_SIZE; j++)
    allBoardMoves.push({"x" : i, "y" : j});

var MAX_MONTECARLO_DEPTH = 10;

function montecarloPlayout(board, player) {
    // initial board has no good atari for us to win immediately
    board = boardCopy(board);
    var montecarloLength = 0;
    while (true) {
        montecarloLength++;
        if (montecarloLength > MAX_MONTECARLO_DEPTH) {
            // Liberty count
            
            var allBlackLiberties = [];
            var allWhiteLiberties = [];
            var markId = 0;
            
            clearDfsStatus();
            for (var i =0; i< BOARD_SIZE; i++)
            for (var j =0; j< BOARD_SIZE; j++) 
            if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
                dfsColor = board[i][j];
                dfsMark = markId;
                dfsBoard = board;
                var gl = libertyDfs(i,j);
                if (board[i][j] == WHITE)
                    allWhiteLiberties.push(gl);
                else
                    allBlackLiberties.push(gl);
                markId++;
            }
            
            allBlackLiberties.sort();
            allWhiteLiberties.sort();
            
            var blackLiberties = 0;
            var w = 1.0;
            for (var i = allBlackLiberties.length - 1; i >=0; i--) {
                blackLiberties += allBlackLiberties[i] * w;
                w /= 2.0;
            }
            
            var whiteLiberties = 0;
            w = 1.0;
            for (var i = allWhiteLiberties.length - 1; i >=0; i--) {
                whiteLiberties += allWhiteLiberties[i] * w;
                w /= 2.0;
            }
            
            var totalLiberties = blackLiberties + whiteLiberties;
            return (playerSign(BLACK) * blackLiberties + playerSign(WHITE) * whiteLiberties) / (3*totalLiberties);
        }
        // Check atari situation
        clearDfsStatus();
        var atari = false;
        var atariX = null;
        var atariY = null;
        var movesForAtari = [];
        var groupId = 0;
        
        for (var i =0; i< BOARD_SIZE; i++)
        for (var j =0; j< BOARD_SIZE; j++) 
        if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
            groupId++;
            dfsColor = board[i][j];
            dfsMark = groupId;
            dfsBoard = board;
            var gl = libertyDfs(i,j);
            if (gl == 1) {
                if (dfsColor == otherPlayer(player)) {
                    return playerSign(player);
                }
                if (!atari) {
                    atari = true;
                    for (var i2 =0; i2< BOARD_SIZE; i2++)
                    for (var j2 =0; j2< BOARD_SIZE; j2++)
                    if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark) {
                        atariX = i2;
                        atariY = j2;
                    }
                }
            }
            else if (gl == 2) {
                for (var i2 =0; i2< BOARD_SIZE; i2++)
                for (var j2 =0; j2< BOARD_SIZE; j2++)
                if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark)
                    movesForAtari.push({"x" : i2, "y" : j2});
            }
        }
        if (atariX !== null) {
            var moveResult = move(board, player, atariX,atariY);
            if (moveResult["status"] != "OK")
                return -playerSign(player);
        }
        else {
            var searchForMove = true;
            if (movesForAtari.length > 0 && Math.random() > 0.1) {
                var moveToDo = movesForAtari[Math.floor(Math.random() * movesForAtari.length)];
                var moveResult = move(board, player, moveToDo.x,moveToDo.y);
                if (moveResult["status"] == "OK")
                    searchForMove = false;
            }
            if (searchForMove) {
                // Choose random move
                shuffleArray(allBoardMoves);
                var moveFound = false;
                for (var index =0; index < allBoardMoves.length; index++) {
                    
                    var i = allBoardMoves[index].x;
                    var j = allBoardMoves[index].y;
                    if (board[i][j] != EMPTY) continue;
                    
                    // Apply heuristics for "acceptable move"
                                    
                    var farAway = true;
                    var FAR_DIST = 2;
            outerFarAway:
                    for (var nx = i-FAR_DIST; nx <= i+FAR_DIST; nx++)
                    for (var ny = j-(FAR_DIST - Math.abs(nx-i)); ny <= j+(FAR_DIST - Math.abs(nx-i)); ny++) 
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        farAway = false;
                        break outerFarAway;
                    }
                    if (farAway)
                        continue; // Never play too far away from friendly stones
                    
                    var loneStone = true;
            outerLoneStone: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        loneStone = false;
                        break outerLoneStone;
                    }
                    if (loneStone && i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1)
                        continue; // Never play on a border, unless there is a friendly stone in the immediate vicinity
                    if (loneStone) {
                        var stoneLiberties = 0;
                        var enemyLiberties = 0;
                        for (var dir = 0; dir < 4; dir++) {
                            var nx = i + dx[dir];
                            var ny = j + dy[dir];
                            if (inRange(nx,ny)) {
                                if (board[nx][ny] == EMPTY)
                                    stoneLiberties++;
                                else if (board[nx][ny] == otherPlayer(player)) {
                                    var thisEnemyLiberties = 0;
                                    for (var dir2 = 0; dir2 < 4; dir2++) {
                                        var nx2 = nx + dx[dir];
                                        var ny2 = ny + dy[dir];
                                        if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                            thisEnemyLiberties++;
                                    }
                                    if (thisEnemyLiberties > enemyLiberties)
                                        enemyLiberties = thisEnemyLiberties;
                                }
                            }
                        }
                        if (stoneLiberties < 2)
                            continue; // Illegal or self-atari
                        if (stoneLiberties < enemyLiberties)
                            continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
                    }
                    
                    var moveResult = move(board, player, i,j);
                    if (moveResult["status"] == "OK") {
                        moveFound = true;
                        break;
                    }
                }
                if (!moveFound)
                    return -playerSign(player);
            }
        }
        player = otherPlayer(player);
    }
}

function getAtariGoAIMove(board, player) {
    var validMove = null;
    var bestMove = null, bestScore = null;
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) {

        if (Math.random() > 0.1) {
            var loneStone = true;
    outerLoneStone: 
            for (var nx = i-1; nx <= i+1; nx++)
            for (var ny = j-1; ny <= j+1; ny++)
            if (inRange(nx,ny) && board[nx][ny] != EMPTY)
            {
                loneStone = false;
                break outerLoneStone;
            }
            if (loneStone)
                continue;
        }



        // Apply heuristics for "acceptable move"
                                                
            var loneStone = true;
    outerLoneStone: 
            for (var nx = i-1; nx <= i+1; nx++)
            for (var ny = j-1; ny <= j+1; ny++)
            if (inRange(nx,ny) && board[nx][ny] == player)
            {
                loneStone = false;
                break outerLoneStone;
            }
            if (loneStone && i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1)
                continue; // Never play on a border, unless there is a friendly stone in the immediate vicinity
            if (loneStone) {
                var stoneLiberties = 0;
                var enemyLiberties = 0;
                for (var dir = 0; dir < 4; dir++) {
                    var nx = i + dx[dir];
                    var ny = j + dy[dir];
                    if (inRange(nx,ny)) {
                        if (board[nx][ny] == EMPTY)
                            stoneLiberties++;
                        else if (board[nx][ny] == otherPlayer(player)) {
                            var thisEnemyLiberties = 0;
                            for (var dir2 = 0; dir2 < 4; dir2++) {
                                var nx2 = nx + dx[dir];
                                var ny2 = ny + dy[dir];
                                if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                    thisEnemyLiberties++;
                            }
                            if (thisEnemyLiberties > enemyLiberties)
                                enemyLiberties = thisEnemyLiberties;
                        }
                    }
                }
                if (stoneLiberties < 2)
                    continue; // Illegal or self-atari
                if (stoneLiberties < enemyLiberties)
                    continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
            }




        var moveResult = move(boardCopy(board), player, i,j);
        var moveDescription = {"x" : i, "y" : j, "newBoard" : moveResult["board"]};
        if (moveResult["status"] == "OK" && moveResult["captures"] > 0)
            return moveDescription;
        if (moveResult["status"] == "OK") {
            if (validMove === null)
                validMove = moveDescription;
            var badMove = false;
        badMoveLoop:
            for (var i2 =0; i2< BOARD_SIZE; i2++)
            for (var j2 =0; j2< BOARD_SIZE; j2++) {
                var moveResult2 = move(boardCopy(moveResult["board"]), otherPlayer(player), i2,j2);
                if (moveResult2["status"] == "OK" && moveResult2["captures"] > 0)
                {
                    badMove = true;
                    break badMoveLoop;
                }
            }
            if (!badMove) {
                var moveScore = 0.0;
                for (var t = 0; t < MONTECARLO_PLAYOUTS; t++)
                    moveScore += montecarloPlayout(moveResult["board"], otherPlayer(player));
                moveScore *= playerSign(player);
                if (bestScore === null || moveScore > bestScore) {
                    bestScore = moveScore;
                    bestMove = moveDescription;
                }
            }
        }
    }
    if (bestMove === null)
        return validMove;
    else
        return bestMove;
}

function makeAIMove() {
    var aiMove = getAtariGoAIMove(globalBoard, currentPlayer);
    makeMove(aiMove.x,aiMove.y);
    drawBoard();
}

function fooClick(event) {
    if (currentPlayer == humanPlayer) {
        var x = event.clientX - gliftDiv.offsetLeft;
        var y = event.clientY - gliftDiv.offsetTop;
        var moveX = Math.round((x - BOARD_X_START) / BOARD_X_CELL);
        var moveY = Math.round((y - BOARD_Y_START) / BOARD_Y_CELL);
        makeMove(moveX, moveY);
        drawBoard();
    }
}

gliftDiv.addEventListener("click", fooClick);
drawBoard();

  </script>
  
</body>
</html>
