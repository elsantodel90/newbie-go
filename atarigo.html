<!doctype html>

<html lang="es">
<head>
  <meta charset="utf-8">

  <title>Ejemplo de atari-go?</title>
  <meta name="description" content="Ejemplo">
  <meta name="author" content="elsantodel90.tk">

  <!--
  <link rel="stylesheet" href="css/styles.css?v=1.0">
   !-->
   
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <script src="js/glift_1_1_2.min.js"></script>
  <link rel = "stylesheet" type = "text/css" href = "css/style.css" />
  <style type="text/css">
      #gliftDiv {
          width:500px;
          height:500px;
      }
  </style>
  <div class="mainrules">
      <h1>Atari-go</h1>
      <p> El Atari-go es una variante del Go particularmente sencilla, muy utilizada en la enseñanza para comenzar a comprender los elementos más básicos del juego.
          La idea es que se juega al igual que el Go en un tablero cuadriculado, colocando <strong>piedras</strong> de colores (<strong>blancas</strong> y <strong>negras</strong>) sobre las <strong>intersecciones</strong> del mismo. Nosotros utilizaremos un tablero de 9x9 intersecciones.
      </p>
      <ul>
      <li>Elementos de juego</li>
          <ul><li> El Atari-go es un juego de dos <strong>jugadores</strong>. Un jugador utiliza las <strong>piedras negras</strong>, y el otro las <strong>blancas</strong>.</li>
              <li> Se juega sobre un tablero de 9x9 <strong>intersecciones</strong>.</li>
              <li> A lo largo del juego, en cada momento algunas intersecciones estarán ocupadas por piedras negras, algunas por piedras blancas, y las restantes se encontrarán vacías.</li>
              <li> Inicialmente, el tablero se encuentra vacío.</li>
              <li> Durante el juego, llamamos un <strong>grupo</strong> de un jugador, a un conjunto maximal de piedras de su color conectadas entre sí horizontal o verticalmente.</li>
              <li> Decimos que una intersección vacía del tablero es una <strong>libertad</strong> de un grupo, cuando es adyacente horizontal o verticalmente a alguna de las piedras del grupo.</li>
          </ul>
      <li>Regla de juego y alternancia</li>
          <ul><li>Comienza el jugador que utiliza las piedras <strong>negras</strong>.
                  Los jugadores <strong>se alternan</strong> realizando jugadas una vez cada uno. Una jugada válida consiste en <strong>colocar una piedra del color del jugador sobre
                  una intersección vacía</strong> del tablero.
          </li></ul>
      <li>Regla de captura</li>
          <ul><li>Si luego de que un jugador realice una jugada, uno o más de los grupos de su rival queda sin libertades, dichos grupos son <strong>capturados</strong> y se sacan todas sus piedras del tablero.</li>
              <li>Notar que en la siguiente posición, si blanco juega en <em>A</em>, logra capturar las dos piedras negras.<br>
                    <img src="images/captura.png"> </li>
              <li>Notar que la jugada indicada con <em>a</em> sería válida para negro, y al realizarla captura la piedra blanca marcada con un círculo.<br>
                    <img src="images/ko.png"> </li>
          </ul>
      <li>Regla de no suicidio</li>
          <ul><li>Si luego de que un jugador realice una jugada (incluyendo de ser necesaria, la aplicación de la regla de captura) un grupo del propio jugador queda sin libertades, tal jugada se considera suicidio y está <strong>prohibida</strong>.</li>
              <li>Por ejemplo, la jugada indicada con <em>A</em> sería inválida para blanco, pues sus piedras del rincón se quedarían sin libertades.<br>
                    <img src="images/suicidio.png"> </li>
          </ul>
      <li>Objetivo:</li>
          <ul><li><strong>El primer jugador en capturar un grupo a su rival gana</strong>. Si un jugador no tiene jugadas válidas, pierde inmediatamente.</li></ul>
      </ul>
  </div>
  <div id="controls">
      <form class="table">
          <span class="table-row">
           <span class="table-cell">
            Fuerza:
            <input type="text" id="strengthTextBox" value=100 style="width:50px;float:right;"><br>
            <input id="setStrengthButton" type="button" value="Cambiar fuerza" />
           </span>
           <span class="table-cell">
            <span class="note">Se recomiendan valores entre 1 y 1000 para la fuerza.
                <strong>Atención</strong>: el tiempo que toma cada jugada es aproximadamente proporcional a la fuerza indicada.</span>
           </span>
          </span>
      </form>
  </div>
  <div>
      <h2 id="atariGoHeader">AtariGo: Fuerza 100</h2>
  </div>
  <div>
      <div style="float: left;" id="gliftDiv">
      </div>
      <div style="float: left;  width:30px;">
          &nbsp;
      </div>
      <div style="float: left;" id="extras">
            Para aprender más sobre Atari-go, se puede aprender sobre los siguientes temas:
            <ul>
                <li><a href="#learn-atari" >Atari</a></li>
                <li><a href="#learn-liberties" >Libertades</a></li>
                <li><a href="#learn-second-line" >Atari en segunda línea</a></li>
                <li><a href="#learn-ladders" >Persecución: Escaleras</a></li>
                <li><a href="#learn-immortal" >Grupo inmortal</a></li>
            </ul>
      </div>
  </div>
  
  <div style="clear:both" id="learn-atari">
      <h1>Atari</h1>
      <ul>
      <li>Definición.</li>
      <li>En Atari-go son especialmente importantes porque no se pueden ignorar. </li>
      <li>Atari doble para capturar.</li>
      </ul>
  </div>
  <div id="learn-liberties">
      <h1>Libertades</h1>
      <ul>
      <li>Conseguir más libertades es bueno. </li>
      <li>Mejor palos que triángulos. </li>
      <li>Triángulo vacío. </li>
      <li>Hay menos libertades en las esquinas y bordes.</li>
      </ul>
  </div>
  <div id="learn-second-line">
      <h1>Atari en segunda línea</h1>
      <ul>
      <li>Ejemplo particular de la idea anterior pues en el borde hay pocas libertades y nos atrapan.</li>
      </ul>
  </div>
  <div id="learn-ladders">
      <h1>Persecución: Escaleras</h1>
      <ul>
      <li>Escaleras.</li>
      <li>Ejemplos:</li>
           <ul><li>canónico</li><li>Contra el borde</li></ul>
      <li>Romper la escalera.</li>
      </ul>
  </div>
  <div id="learn-immortal">
      <h1>Grupo inmortal</h1>
      <ul>
      <li> Dos libertades en un ojo.</li>
      </ul>
  </div>
  
  <script>

var BOARD_SIZE = 9;
var BOARD_X_START = 40;
var BOARD_Y_START = 40;
var BOARD_X_CELL = 52;
var BOARD_Y_CELL = 52;

var EMPTY = 0;
var BLACK = 1;
var WHITE = 2;
var KOBAN = 3;

var currentPlayer = BLACK;
var globalBoard = []; 
for (var i = 0; i < BOARD_SIZE; i++) {
    globalBoard.push([]);
    for (var j = 0; j < BOARD_SIZE; j++)
        globalBoard[i].push(EMPTY);
}

function boardCopy(boardToCopy) {
    var ret = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        ret.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            ret[i].push(boardToCopy[i][j]);
    }
    return ret;
}

var boardHistory = [boardCopy(globalBoard)];
var moveHistory = [];
var humanPlayer = BLACK;


function toLetter(index) {
    return String.fromCharCode('a'.charCodeAt(0) + index);
}

function getSgfString() {
    var ret = "(;SZ[" + BOARD_SIZE + "]";
    for (var i = 0; i < moveHistory.length; i++) {
        var move = moveHistory[i];
        var colorLetter;
        if (move.color == WHITE)
            colorLetter = 'W';
        else if (move.color == BLACK)
            colorLetter = 'B';
        else
            throw "Assertion error: Invalid COLOR in move " + i + " = " + move;
        ret += ";" + colorLetter + "[" + toLetter(move.x) + toLetter(move.y) + "]";
    }
    ret += ")";
    return ret;
}

var gliftWidget = null;

function drawBoard() {
    //document.getElementById("boardText").innerHTML = getBoardHTML(globalBoard);
    if (gliftWidget !== null)
        gliftWidget.destroy();
    gliftWidget = glift.create({
      divId: "gliftDiv",
      sgfDefaults : {
        sgfString : getSgfString(),
        boardRegion : glift.enums.boardRegions.ALL,
        initialPosition : moveHistory.length,
        widgetType : glift.WidgetType.GAME_VIEWER,
        uiComponents : ["BOARD"]
      },
      display: {
        theme: 'DEPTH',
        goBoardBackground: 'images/purty_wood.png'
      }
    });
}

function cellToChar(cell) {
    if (cell == EMPTY)
        return '.';
    else if (cell == BLACK)
        return 'B';
    else if (cell == WHITE)
        return 'W';
    else if (cell == KOBAN)
        return 'K';
    else
        throw "Assertion: contenido de intersección inválida. " + cell;
}

function getBoardHTML(board) {
    var ret = "";
    for (var i = 0; i < BOARD_SIZE; i++) {
        for (var j = 0; j < BOARD_SIZE; j++)
            ret += cellToChar(board[j][i]);
        ret += "<br>";
    }
    return ret;
}

function alertUser(message) {
    alert(message);
}

var dx = [0,0,1,-1];
var dy = [1,-1,0,0];

var dfsStatus;
var dfsColor;
var dfsMark;
var dfsBoard;

function clearDfsStatus() {
    dfsStatus = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        dfsStatus.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            dfsStatus[i].push(0);
    }
}

function inRange(x,y) {
    return 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE;
}

function libertyDfs(x,y) {
    dfsStatus[x][y] = dfsMark;
    var liberties = 0;
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && dfsStatus[nx][ny] != dfsMark) {
            if (dfsBoard[nx][ny] == EMPTY)
            {
                liberties++;
                dfsStatus[nx][ny] = dfsMark;
            }
            else if (dfsBoard[nx][ny] == dfsColor)
                liberties += libertyDfs(nx,ny);
        }
    }
    return liberties;
}

function otherPlayer(player) {
    if (player === undefined)
        throw "Assertion: hay que pasarle parametro a otherPlayer!";
    if (player == BLACK)
        return WHITE;
    else if (player == WHITE)
        return BLACK;
    else
        throw "Assertion: el jugador solo puede ser blanco o negro! Es en su lugar " + player;
}

function move(board, player, x,y) {
    if (!inRange(x,y))
        return {"status" : "OUT_OF_RANGE"};
    if (board[x][y] == KOBAN)
        return {"status" :  "No se puede jugar en esa intersección debido a la regla del Ko: se repetiría la posición del tablero."};
    if (board[x][y] != EMPTY)
        return {"status" : "Solamente se puede jugar en una intersección vacía del tablero."};
    
    // Clear the koban
    var kobanX = null, kobanY = null;
    for (var i = 0; i < BOARD_SIZE; i++)
    for (var j = 0; j < BOARD_SIZE; j++)
        if (board[i][j] == KOBAN)
        {
            board[i][j] = EMPTY;
            kobanX = i;
            kobanY = j;
        }
    
    clearDfsStatus();
    
    var dirAtari = [false, false, false, false];
    var atari = [false, false, false, false];
    var playerSafe = false;
    
    var moveWasAtari = false;
    
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && board[nx][ny] == EMPTY)
            playerSafe = true;
        if (inRange(nx,ny) && dfsStatus[nx][ny] == 0 && board[nx][ny] != EMPTY) {
            dfsColor = board[nx][ny];
            dfsMark = dir+1;
            dfsBoard = board;
            var gl = libertyDfs(nx,ny);
            if (gl == 1) {
                dirAtari[dir] = true;
                atari[dfsColor] = true;
            }
            else if (dfsColor == player)
                playerSafe = true;
            if (gl == 2 && dfsColor != player)
                moveWasAtari = true;
        }
    }
    
    if (!playerSafe && !atari[otherPlayer(player)])
    {
        if (kobanX !== null)
            board[kobanX][kobanY] = KOBAN;
        return {"status" : "No se puede jugar en esa intersección debido a la regla de no suicidio: la jugada crearía un grupo propio sin libertades."};
    }
    
    // The move is valid
    
    board[x][y] = player;
    
    var captures = 0;
    var captureX, captureY;
    if (atari[otherPlayer(player)])
    {
        for (var i = 0; i < BOARD_SIZE; i++)
        for (var j = 0; j < BOARD_SIZE; j++)
            if (dfsStatus[i][j] > 0 && board[i][j] == otherPlayer(player) && dirAtari[dfsStatus[i][j] - 1])
            {
                board[i][j] = EMPTY;
                captureX = i;
                captureY = j;
                captures++;
            }
    }

    if (captures == 1) {
        // Check for lone stone
        var loneStone = true;
        for (var dir = 0; dir < 4; dir++) {
            var nx = x + dx[dir];
            var ny = y + dy[dir];
            if (inRange(nx,ny) && (nx != captureX || ny != captureY) && (board[nx][ny] != otherPlayer(player)))
                loneStone = false;
        }
        if (loneStone)
            board[captureX][captureY] = KOBAN;
    }
    
    return {"status" : "OK", "board" : board, "captures" : captures, "atari" : moveWasAtari};
}

function resetGame() {
    currentPlayer = BLACK;
    humanPlayer = otherPlayer(humanPlayer);
    globalBoard = [];
    for (var i = 0; i < BOARD_SIZE; i++) {
        globalBoard.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            globalBoard[i].push(EMPTY);
    }
    boardHistory = [boardCopy(globalBoard)];
    moveHistory = [];
    if (currentPlayer != humanPlayer)
        setTimeout(makeAIMove, 100);
}

function showMessageFunction(humanWins) {
    var message;
    if (humanWins)
        message = "¡VICTORIA!";
    else
        message = "DERROTA :(";
    return function() {
        alertUser(message);
        resetGame();
        drawBoard();
    };
}

function noLegalMove(board, player) {
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) 
        if (board[i][j] == EMPTY) {
            var moveResult = move(boardCopy(board), player, i,j);
            if (moveResult["status"] == "OK")
                return false;
        }
    return true;
}

function makeMove(x,y) {
    var moveResult = move(globalBoard, currentPlayer, x,y);
    if (moveResult["status"] == "OK") {
        boardHistory.push(boardCopy(globalBoard));
        moveHistory.push({"color" : currentPlayer, "x" : x, "y" : y});
        if (moveResult["captures"] > 0 || noLegalMove(globalBoard, otherPlayer(currentPlayer)))
            setTimeout(showMessageFunction(currentPlayer == humanPlayer) , 100);
        else {
            currentPlayer = otherPlayer(currentPlayer);
            if (currentPlayer != humanPlayer)
                setTimeout(makeAIMove, 100);
        }
    }
    else if (moveResult["status"] != "OUT_OF_RANGE")
        alertUser(moveResult["status"]);
}

var gliftDiv = document.getElementById("gliftDiv");

function playerSign(player) {
    if (player == BLACK)
        return 1.0;
    else
        return -1.0;
}

var MONTECARLO_PLAYOUTS = 100;//4000;

function setStrength() {
    MONTECARLO_PLAYOUTS = parseInt(document.getElementById("strengthTextBox").value);
    document.getElementById("atariGoHeader").innerHTML = "AtariGo: Fuerza " + MONTECARLO_PLAYOUTS;
}

document.getElementById("setStrengthButton").onclick = setStrength;

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

var allBoardMoves = [];
for (var i =0; i< BOARD_SIZE; i++)
for (var j =0; j< BOARD_SIZE; j++)
    allBoardMoves.push({"x" : i, "y" : j});

var MAX_MONTECARLO_DEPTH = 10;

function montecarloPlayout(board, player) {
    // initial board has no good atari for us to win immediately
    board = boardCopy(board);
    var montecarloLength = 0;
    while (true) {
        montecarloLength++;
        if (montecarloLength > MAX_MONTECARLO_DEPTH) {
            // Liberty count
            
            var allBlackLiberties = [];
            var allWhiteLiberties = [];
            var markId = 0;
            
            clearDfsStatus();
            for (var i =0; i< BOARD_SIZE; i++)
            for (var j =0; j< BOARD_SIZE; j++) 
            if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
                dfsColor = board[i][j];
                dfsMark = markId;
                dfsBoard = board;
                var gl = libertyDfs(i,j);
                if (board[i][j] == WHITE)
                    allWhiteLiberties.push(gl);
                else
                    allBlackLiberties.push(gl);
                markId++;
            }
            
            allBlackLiberties.sort();
            allWhiteLiberties.sort();
            
            var blackLiberties = 0;
            var w = 1.0;
            for (var i = allBlackLiberties.length - 1; i >=0; i--) {
                blackLiberties += allBlackLiberties[i] * w;
                w /= 2.0;
            }
            
            var whiteLiberties = 0;
            w = 1.0;
            for (var i = allWhiteLiberties.length - 1; i >=0; i--) {
                whiteLiberties += allWhiteLiberties[i] * w;
                w /= 2.0;
            }
            
            var totalLiberties = blackLiberties + whiteLiberties;
            return (playerSign(BLACK) * blackLiberties + playerSign(WHITE) * whiteLiberties) / (3*totalLiberties);
        }
        // Check atari situation
        clearDfsStatus();
        var atari = false;
        var atariX = null;
        var atariY = null;
        var movesForAtari = [];
        var groupId = 0;
        
        for (var i =0; i< BOARD_SIZE; i++)
        for (var j =0; j< BOARD_SIZE; j++) 
        if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
            groupId++;
            dfsColor = board[i][j];
            dfsMark = groupId;
            dfsBoard = board;
            var gl = libertyDfs(i,j);
            if (gl == 1) {
                if (dfsColor == otherPlayer(player)) {
                    return playerSign(player);
                }
                if (!atari) {
                    atari = true;
                    for (var i2 =0; i2< BOARD_SIZE; i2++)
                    for (var j2 =0; j2< BOARD_SIZE; j2++)
                    if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark) {
                        atariX = i2;
                        atariY = j2;
                    }
                }
            }
            else if (gl == 2) {
                for (var i2 =0; i2< BOARD_SIZE; i2++)
                for (var j2 =0; j2< BOARD_SIZE; j2++)
                if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark)
                    movesForAtari.push({"x" : i2, "y" : j2});
            }
        }
        if (atariX !== null) {
            var moveResult = move(board, player, atariX,atariY);
            if (moveResult["status"] != "OK")
                return -playerSign(player);
        }
        else {
            var searchForMove = true;
            if (movesForAtari.length > 0 && Math.random() > 0.1) {
                var moveToDo = movesForAtari[Math.floor(Math.random() * movesForAtari.length)];
                var moveResult = move(board, player, moveToDo.x,moveToDo.y);
                if (moveResult["status"] == "OK")
                    searchForMove = false;
            }
            if (searchForMove) {
                // Choose random move
                shuffleArray(allBoardMoves);
                var moveFound = false;
                for (var index =0; index < allBoardMoves.length; index++) {
                    
                    var i = allBoardMoves[index].x;
                    var j = allBoardMoves[index].y;
                    if (board[i][j] != EMPTY) continue;
                    
                    // Apply heuristics for "acceptable move"
                                    
                    var farAway = true;
                    var FAR_DIST = 2;
            outerFarAway:
                    for (var nx = i-FAR_DIST; nx <= i+FAR_DIST; nx++)
                    for (var ny = j-(FAR_DIST - Math.abs(nx-i)); ny <= j+(FAR_DIST - Math.abs(nx-i)); ny++) 
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        farAway = false;
                        break outerFarAway;
                    }
                    if (farAway)
                        continue; // Never play too far away from friendly stones
                    
                    var loneStone = true;
            outerLoneStone: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        loneStone = false;
                        break outerLoneStone;
                    }
                    if (loneStone && i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1)
                        continue; // Never play on a border, unless there is a friendly stone in the immediate vicinity
                    if (loneStone) {
                        var stoneLiberties = 0;
                        var enemyLiberties = 0;
                        for (var dir = 0; dir < 4; dir++) {
                            var nx = i + dx[dir];
                            var ny = j + dy[dir];
                            if (inRange(nx,ny)) {
                                if (board[nx][ny] == EMPTY)
                                    stoneLiberties++;
                                else if (board[nx][ny] == otherPlayer(player)) {
                                    var thisEnemyLiberties = 0;
                                    for (var dir2 = 0; dir2 < 4; dir2++) {
                                        var nx2 = nx + dx[dir];
                                        var ny2 = ny + dy[dir];
                                        if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                            thisEnemyLiberties++;
                                    }
                                    if (thisEnemyLiberties > enemyLiberties)
                                        enemyLiberties = thisEnemyLiberties;
                                }
                            }
                        }
                        if (stoneLiberties < 2)
                            continue; // Illegal or self-atari
                        if (stoneLiberties < enemyLiberties)
                            continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
                    }
                    
                    var moveResult = move(board, player, i,j);
                    if (moveResult["status"] == "OK") {
                        moveFound = true;
                        break;
                    }
                }
                if (!moveFound)
                    return -playerSign(player);
            }
        }
        player = otherPlayer(player);
    }
}


var ATARI_MINIMAX_EXPLORATION_PLIES = 20;
var MINIMAX_EXPLORATION_PLIES = 2;

function recursiveMinimax(board, player, plies, atariPlayer) {
    board = boardCopy(board);
    
    // Check atari situation
    var keepMakingForcedMoves = true;
    while (keepMakingForcedMoves) {
        keepMakingForcedMoves = false;
        clearDfsStatus();
        var atariX = null;
        var atariY = null;
        var groupId = 0;
        
        for (var i =0; i< BOARD_SIZE; i++)
        for (var j =0; j< BOARD_SIZE; j++) 
        if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
            groupId++;
            dfsColor = board[i][j];
            dfsMark = groupId;
            dfsBoard = board;
            if (libertyDfs(i,j) == 1) {
                if (dfsColor == otherPlayer(player))
                    return playerSign(player);
                if (atariX === null) {
                    for (var i2 =0; i2< BOARD_SIZE; i2++)
                    for (var j2 =0; j2< BOARD_SIZE; j2++)
                    if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark) {
                        atariX = i2;
                        atariY = j2;
                    }
                }
            }
        }
        if (atariX !== null) {
            var moveResult = move(board, player, atariX,atariY);
            if (moveResult["status"] != "OK")
                return -playerSign(player);
            player = otherPlayer(player);
            keepMakingForcedMoves = true;
        }
    }
    
    // Normal search (counts as a ply)
    
    if (plies == 0) return 0.0;
    var bestResultSoFar = -playerSign(player);
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) 
        if (board[i][j] == EMPTY) {
            if (atariPlayer == EMPTY) {
                var loneStone = true;
        outerLoneStone: 
                for (var nx = i-1; nx <= i+1; nx++)
                for (var ny = j-1; ny <= j+1; ny++)
                if (inRange(nx,ny) && board[nx][ny] != EMPTY)
                {
                    loneStone = false;
                    break outerLoneStone;
                }
                if (loneStone)
                    continue;
            } 
            else if (atariPlayer != player)
                return 0.0;
            
            var moveResult = move(board, player, i,j);
            if (moveResult["status"] == "OK") {
                if (moveResult["captures"] > 0)
                    return playerSign(player);
                if (atariPlayer == EMPTY || moveResult["atari"]) {
                    var childValue = recursiveMinimax(board, otherPlayer(player), plies - 1, atariPlayer);
                    if (childValue == playerSign(player))
                        return childValue;
                    else if (childValue == 0.0)
                        bestResultSoFar = childValue;
                }
                board[i][j] = EMPTY;
            }
        }
    return bestResultSoFar;
}

function getAtariGoAIMove(board, player, continuation) {
    if (MONTECARLO_PLAYOUTS >= 500)
        MINIMAX_EXPLORATION_PLIES = 2;
    else
        MINIMAX_EXPLORATION_PLIES = 1;
    var okMoves = [];
    var validMoves = [];
    var winningMove = null;
    
    var afterMinimax;
    
    // This is just a loop:
    //    for (var i =0; i< BOARD_SIZE; i++)
    //    for (var j =0; j< BOARD_SIZE; j++) 
    // Divided step by step using setTimeout so that the browser is not blocked (at least not too much)
    var minimaxLoopStep = function(i,j) {
        if (board[i][j] == EMPTY) {
            var moveResult = move(boardCopy(board), player, i,j);
            var moveDescription = {"x" : i, "y" : j, "newBoard" : moveResult["board"]};
            if (moveResult["status"] == "OK") {
                if (moveResult["captures"] > 0)
                    return continuation(moveDescription);
                validMoves.push({"x" : i, "y" : j, "result" : moveResult, "description" : moveDescription});
                
                var childResult = recursiveMinimax(moveResult["board"], otherPlayer(player), ATARI_MINIMAX_EXPLORATION_PLIES, player);
                if (childResult == playerSign(player))
                    winningMove = moveDescription;
                else {
                    childResult = recursiveMinimax(moveResult["board"], otherPlayer(player), ATARI_MINIMAX_EXPLORATION_PLIES, otherPlayer(player));
                    if (childResult != -playerSign(player)) {
                        childResult = recursiveMinimax(moveResult["board"], otherPlayer(player), MINIMAX_EXPLORATION_PLIES, EMPTY);
                        if (childResult == playerSign(player))
                            winningMove = moveDescription;
                        else if (childResult == 0.0)
                            okMoves.push({"x" : i, "y" : j, "result" : moveResult, "description" : moveDescription});
                    }
                }
            }
        }
        j++;
        if (j >= BOARD_SIZE) {
            j=0;
            i++;
            if (i >= BOARD_SIZE) {
                afterMinimax();
                return;
            }
        }
        setTimeout(function (){ minimaxLoopStep(i,j);}, 0);
    }
    
    afterMinimax = function() {
        
        if (winningMove !== null)
            return continuation(winningMove);
        if (okMoves.length == 0)
            okMoves = validMoves;
        var bestMove = null, bestScore = null;
        
        var secondPartForLoop = function(moveIndex) {
            for (var dummyVar = 0; dummyVar < 1; dummyVar++) { // Single element for, so that we can use "continue" inside it to escape.
                var i = okMoves[moveIndex].x;
                var j = okMoves[moveIndex].y;
                
                {
                    
                    var farFromEnemy = true;
            farFromEnemyLoop: 
                    for (var nx = i-3; nx <= i+3; nx++)
                    for (var ny = j-(3-Math.abs(nx-i)); ny <= j+(3-Math.abs(nx-i)); ny++)
                    if (inRange(nx,ny) && board[nx][ny] == otherPlayer(player))
                    {
                        farFromEnemy = false;
                        break farFromEnemyLoop;
                    }
                    if (!farFromEnemy) {
                        var loneStone = true;
                outerLoneStone1: 
                        for (var nx = i-2; nx <= i+2; nx++)
                        for (var ny = j-(2-Math.abs(nx-i)); ny <= j+(2-Math.abs(nx-i)); ny++)
                        if (inRange(nx,ny) && board[nx][ny] == player)
                        {
                            loneStone = false;
                            break outerLoneStone1;
                        }
                        if (loneStone)
                            continue;
                    }
                }



                // Apply heuristics for "acceptable move"
                                                        
                    var loneStone = true;
            outerLoneStone2: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        loneStone = false;
                        break outerLoneStone2;
                    }
                    if (loneStone && (i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1))
                        continue; // Never play on a border, unless there is a friendly stone in the immediate vicinity
                    if (loneStone) {
                        var stoneLiberties = 0;
                        var enemyLiberties = 0;
                        for (var dir = 0; dir < 4; dir++) {
                            var nx = i + dx[dir];
                            var ny = j + dy[dir];
                            if (inRange(nx,ny)) {
                                if (board[nx][ny] == EMPTY)
                                    stoneLiberties++;
                                else if (board[nx][ny] == otherPlayer(player)) {
                                    var thisEnemyLiberties = 0;
                                    for (var dir2 = 0; dir2 < 4; dir2++) {
                                        var nx2 = nx + dx[dir];
                                        var ny2 = ny + dy[dir];
                                        if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                            thisEnemyLiberties++;
                                    }
                                    if (thisEnemyLiberties > enemyLiberties)
                                        enemyLiberties = thisEnemyLiberties;
                                }
                            }
                        }
                        if (stoneLiberties < 2)
                            continue; // Illegal or self-atari
                        if (stoneLiberties < enemyLiberties)
                            continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
                    }

                var moveResult = okMoves[moveIndex].result;
                var moveDescription = okMoves[moveIndex].description;
                
                var moveScore = 0.0;
                for (var t = 0; t < MONTECARLO_PLAYOUTS; t++)
                    moveScore += montecarloPlayout(moveResult["board"], otherPlayer(player));
                moveScore *= playerSign(player);
                if (bestScore === null || moveScore > bestScore) {
                    bestScore = moveScore;
                    bestMove = moveDescription;
                }
            }
            moveIndex++;
            if (moveIndex < okMoves.length)
                setTimeout(function() {secondPartForLoop(moveIndex);}, 0);
            else {
                if (bestMove === null)
                    return continuation(validMoves[Math.floor(Math.random() * validMoves.length)]);
                else
                    return continuation(bestMove);
            }
        }
        
        if (0 < okMoves.length)
            setTimeout(function() {secondPartForLoop(0);}, 0);
        else {
            if (bestMove === null)
                return continuation(validMoves[Math.floor(Math.random() * validMoves.length)]);
            else
                return continuation(bestMove);
        }
    }
    
    setTimeout(function (){ minimaxLoopStep(0,0);}, 0);
}

function makeAIMove() {
    document.getElementById("atariGoHeader").innerHTML += " [ buscando jugada... ]";
    getAtariGoAIMove(globalBoard, currentPlayer, function(aiMove) {
        makeMove(aiMove.x,aiMove.y);
        drawBoard();
        document.getElementById("atariGoHeader").innerHTML = "AtariGo: Fuerza " + MONTECARLO_PLAYOUTS;
    });
}

function fooClick(event) {
    if (currentPlayer == humanPlayer) {
        var x = event.pageX - gliftDiv.offsetLeft;
        var y = event.pageY - gliftDiv.offsetTop;
        var moveX = Math.round((x - BOARD_X_START) / BOARD_X_CELL);
        var moveY = Math.round((y - BOARD_Y_START) / BOARD_Y_CELL);
        makeMove(moveX, moveY);
        drawBoard();
    }
}

gliftDiv.addEventListener("click", fooClick);
drawBoard();

  </script>
  
</body>
</html>
