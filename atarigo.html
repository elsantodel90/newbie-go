<!doctype html>

<html lang="es">
<head>
  <meta charset="utf-8">

  <title>Ejemplo de atari-go?</title>
  <meta name="description" content="Ejemplo">
  <meta name="author" content="elsantodel90.tk">
   
  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <script src="dependencies/glift/glift_1_1_2.min.js"></script>
  <script src="dependencies/sweetalert/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="dependencies/sweetalert/sweetalert.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
  <style type="text/css">
      #gliftDiv {
          width:500px;
          height:500px;
      }
      .tableroEjemplo {
          width:200px;
          height:200px;
      }
  </style>
  <div class="mainrules">
      <h1>Atari-go</h1>
      <p> El Atari-go es una variante del Go particularmente sencilla, muy utilizada en la enseñanza para comenzar a comprender los elementos más básicos del juego.
          La idea es que se juega al igual que el Go en un tablero cuadriculado, colocando <strong>piedras</strong> de colores (<strong>blancas</strong> y <strong>negras</strong>) sobre las <strong>intersecciones</strong> del mismo. Nosotros utilizaremos un tablero de 9x9 intersecciones.
      </p>
      <ul>
      <li>Elementos de juego</li>
          <ul><li> El Atari-go es un juego de dos <strong>jugadores</strong>. Un jugador utiliza las <strong>piedras negras</strong>, y el otro las <strong>blancas</strong>.</li>
              <li> Se juega sobre un tablero de 9x9 <strong>intersecciones</strong>, que inicialmente se encuentra vacío, como se muestra en la figura.</li>
              <div id="tableroEjemplo" class="tableroEjemplo"></div>
              <li> A lo largo del juego, en cada momento algunas intersecciones estarán ocupadas por piedras negras, algunas por piedras blancas, y las restantes se encontrarán vacías.</li>
              <div id="tableroEjemplo2" class="tableroEjemplo"></div>
              <li> Durante el juego, llamamos un <strong>grupo</strong> de un jugador, a un conjunto maximal de piedras de su color conectadas entre sí horizontal o verticalmente. En la figura hay 6 grupos, 4 blancos (uno de ellos es una piedra individual marcada con <em>A</em>) y 2 negros.</li>
              <div id="tableroEjemplo3" class="tableroEjemplo"></div>
              <li> Decimos que una intersección vacía del tablero es una <strong>libertad</strong> de un grupo, cuando es adyacente horizontal o verticalmente a alguna de las piedras del grupo. En la figura siguiente se muestran las libertades de los grupos anteriormente marcados con <em>X</em> y <em>O</em>, utilizando esos mismos símbolos. Además, se encuentra marcada especialmente con un triángulo la única libertad compartida entre esos dos grupos.</li>
              <div id="tableroEjemplo4" class="tableroEjemplo"></div>
          </ul>
      <li>Regla de juego y alternancia</li>
          <ul><li>Comienza el jugador que utiliza las piedras <strong>negras</strong>.
                  Los jugadores <strong>se alternan</strong> realizando jugadas una vez cada uno. Una jugada válida consiste en <strong>colocar una piedra del color del jugador sobre
                  una intersección vacía</strong> del tablero.
          </li>
          <div id="tableroEjemplo5" class="tableroEjemplo"></div>
          </ul>
      <li>Regla de captura</li>
          <ul><li>Si luego de que un jugador realice una jugada, uno o más de los grupos de su rival quedan sin libertades, dichos grupos son <strong>capturados</strong> y se sacan todas sus piedras del tablero.</li>
              <li>En el siguiente ejemplo, se muestra en cada caso cómo si blanco juega en <em>A</em>, logra capturar las piedras negras marcadas.<br>
                    <div id="tableroEjemplo6" class="tableroEjemplo"></div>
          </ul>
      <li>Regla de no suicidio</li>
          <ul><li>Si luego de que un jugador realice una jugada (incluyendo de ser necesaria, la aplicación de la regla de captura) un grupo del propio jugador queda sin libertades, tal jugada se considera suicidio y está <strong>prohibida</strong>.</li>
              <li>Por ejemplo, la jugada indicada con <em>A</em> sería inválida para blanco, pues sus piedras del rincón se quedarían sin libertades. Si negro jugara allí, en cambio, la jugada sería legal, y capturaría en el proceso las dos piedras blancas.<br>
                    <div id="tableroEjemplo7" class="tableroEjemplo"></div>
          </ul>
      <li>Objetivo:</li>
          <ul><li><strong>En Atari-go, el primer jugador en capturar un grupo de su rival gana</strong>.</li>
              <li>Si un jugador no tiene jugadas válidas, pierde inmediatamente.</li></ul>
      </ul>
  </div>
  <h1 id="atariBotHeaderDiv">AtariBot</h1>
  <p>A continuación, se puede practicar Atari-go contra la computadora. Es posible seleccionar la fuerza del programa desde 1 hasta 9. Cuánto más fuerte, más tiempo toma el cálculo de jugadas.</p>
  <p>Cuando una partida termina, el programa lo indica y comienza una nueva inmediatamente, alternando a quién le toca jugar con negras en cada partida.</p>
  <div id="controls">
      <form>
            Fuerza:
            &nbsp; 1 <input type="radio" id="buttonStrength1" name="strengthSelector" value="1" checked="checked">
            &nbsp; 2 <input type="radio" id="buttonStrength2" name="strengthSelector" value="2">
            &nbsp; 3 <input type="radio" id="buttonStrength3" name="strengthSelector" value="3">
            &nbsp; 4 <input type="radio" id="buttonStrength4" name="strengthSelector" value="4">
            &nbsp; 5 <input type="radio" id="buttonStrength5" name="strengthSelector" value="5">
            &nbsp; 6 <input type="radio" id="buttonStrength6" name="strengthSelector" value="6">
            &nbsp; 7 <input type="radio" id="buttonStrength7" name="strengthSelector" value="7">
            &nbsp; 8 <input type="radio" id="buttonStrength8" name="strengthSelector" value="8">
            &nbsp; 9 <input type="radio" id="buttonStrength9" name="strengthSelector" value="9">
      </form>
      <button type="button" id="undoButton">Deshacer jugada</button>
  </div>
  <div>
      <h2><span id="atariGoHeader">AtariBot: Fuerza 1</span><span id="percentageIndicator"></span></h2>
  </div>
  <div>
      <div style="float: left;" id="gliftDiv">
      </div>
      <div style="float: left;  width:30px;">
          &nbsp;
      </div>
      <div style="float: left;" id="extras">
            Si le interesa mejorar su Atari-go, <br>puede aprender sobre los siguientes temas:
            <ul>
                <li><a href="#learn-liberties" >Libertades</a></li>
                <li><a href="#learn-atari" >Atari</a></li>
                <li><a href="#learn-double-atari" >Atari Doble</a></li>
                <li><a href="#learn-second-line" >Atari en segunda línea</a></li>
                <li><a href="#learn-succesive-ataris" >Ataris Sucesivos</a></li>
                <li><a href="#learn-ladders" >Persecución: Escaleras</a></li>
                <li><a href="#learn-immortal" >Grupo inmortal</a></li>
            </ul>
      </div>
  </div>
  
  <div style="clear:both" id="learn-liberties">
      <h1>Libertades</h1>
      <ul>
      <li>Un grupo es capturado cuando se queda sin libertades.</li>
      <li>Además en cada jugada, podemos quitarle <strong>como mucho una libertad</strong> a un cierto grupo rival.</li>
      <li>Por lo tanto, en general es buena idea tratar de asegurarse de tener muchas libertades, y tratar de reducir las posibilidades de obtener libertades del rival. </li>
      <li>Una consecuencia inmediata de esta observación es que no es buena idea jugar piedras aisladas, sin algún motivo concreto, contra un borde o una esquina, ya que allí tienen menos libertades:
          En el ejemplo se muestran 3 piedras, con sus libertades marcadas. Se aprecia fácilmente que una piedra suelta tiene normalmente 4 libertades, mientras que en el borde tiene solamente 3, y en
          la esquina tan sólo 2.</li>
      <div id="tableroEjemplo8" class="tableroEjemplo"></div>
      <li>Además, a la hora de armar grupos, es conveniente apuntar a crear formas con las que se tengan muchas libertades. En general, son mejores las denominadas <em>paredes</em>, secuencias de piedras
           consecutivas todas en la misma línea recta, que figuras con <em>giros</em>.</li>
      <li>Por ejemplo en la figura se muestra una pared blanca de 3 piedras, contra la mala forma que se conoce como <em>triángulo vacío</em>: Se aprecia fácilmente que el triángulo vacío de negro tiene una libertad menos usando la misma cantidad de piedras.</li>
      <div id="tableroEjemplo9" class="tableroEjemplo"></div>
      <li>A continuación tenemos un ejemplo grande, donde mostramos una pared de 7 piedras, en comparación a un grupo con muchos giros también formado por 7 piedras: mientras que la pared tiene 16 libertades en este caso, el grupo con giros tiene solamente 11: cada giro pierde una libertad en comparación a la pared.</li>
      <div id="tableroEjemplo10" class="tableroEjemplo"></div>
      <div id="tableroEjemplo11" class="tableroEjemplo"></div>
      <li>Finalmente, a continuación mostramos el ejemplo máximo de mala forma: una masa de piedras totalmente compacta. Se puede ver que <strong>sacando</strong> por ejemplo la piedra central del grupo negro de la izquierda, el grupo tiene una libertad más completamente segura, con lo cual es claro que esa piedra central no hace más que estorbar y por lo tanto es una jugada perdida.</li>
      <div id="tableroEjemplo12" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div id="learn-atari">
      <h1>Atari</h1>
      <ul>
      <li>Se denomina <em>atari</em> a la situación que se produce cuando existe en el tablero un grupo con una única libertad. Se dice que dicho grupo <em>está en atari</em>, y se suele decir también que una jugada que
          pone un grupo en atari <em>es atari</em>.</li>
      <li>En Atari-go son especialmente importantes porque no se pueden ignorar: Si un grupo está en atari, significa que con una jugada más puede ser capturado, y por lo tanto si un jugador no hace nada al respecto,
          perderá en la siguiente jugada si su rival ejecuta la captura (en cierta forma se parece en Atari-go al ``jaque'' del ajedrez).</li>
      <li>Es muy importante entonces estar alerta y poder <strong>reconocer ataris rápidamente</strong>.</li>
      <li>Además, al razonar sobre lo que el oponente podría contestar a una de nuestras jugadas, si la jugada es atari sabemos que el rival <strong>estará obligado a defenderse</strong>, lo cual puede ayudar a razonar y crear un plan.</li>
      <li>A continuación se muestra un ejemplo donde blanco lleva a cabo un atari, y a continuación negro se defiende para no ser capturado.</li>
      <div id="tableroEjemplo13" class="tableroEjemplo"></div>
      <li>A continuación se muestra el mismo atari del ejemplo anterior, pero negro, en su afán de llevar a cabo su propio atari, no se defiende adecuadamente y es capturado en la siguiente jugada.</li>
      <div id="tableroEjemplo14" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div style="clear:both" id="learn-double-atari">
      <h1>Atari Doble</h1>
      <ul>
      <li>El atari doble es una <em>técnica de captura</em>.</li>
      <li>Consiste en una jugada que pone en atari a dos grupos <strong>a la vez</strong>.</li>
      <li>Como generalmente el rival no puede defender ambos en una sola jugada, alguno de los dos grupos será capturado necesariamente.</li>
      <li>En los siguientes ejemplos se muestra un atari doble por parte de blanco, y se ve que sin importar qué grupo defienda negro, su otro grupo será capturado.</li>
      <div id="tableroEjemplo15" class="tableroEjemplo"></div>
      <div id="tableroEjemplo16" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div id="learn-second-line">
      <h1>Atari en segunda línea</h1>
      <ul>
      <li>El atari en segunda línea es un tipo de atari muy común y particular, que se produce sobre una piedra a solamente <strong>una intersección</strong> de separación del borde del tablero.</li>
      <li>Cuando se produce un atari de estas características de forma tal que para defender la piedra, el jugador se ve obligado a jugar contra el borde, la falta de libertades que hay allí lo lleva a ser capturado.</li>
      <li>Al ser tan común y producir una captura segura, es importante aprender a reconocer rápidamente las posibilidades de atari en segunda línea, <strong>tanto propias como del rival</strong>.</li>
      <li>En el siguiente ejemplo se muestra un típico atari en segunda línea, y como por más que se intente escapar, al estar contra el borde no hay suficiente espacio y la captura es inevitable.</li>
      <div id="tableroEjemplo17" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div style="clear:both" id="learn-succesive-ataris">
      <h1>Ataris Sucesivos</h1>
      <ul>
      <li>Los ataris sucesivos son una <em>técnica de captura</em>.</li>
      <li>La idea es utilizar un primer atari a modo de <em>distracción</em>, para ubicar una piedra en un lugar propicio para permitir posteriores ataris que logren la captura deseada.</li>
      <li>A continuación se muestra un ejemplo donde se observa una piedra negra en segunda línea marcada con <em>A</em>. Al estar en segunda línea, sería tentador tratar de atraparla mediante un <a href="#learn-second-line">atari en segunda línea</a>.
          Sin embargo, la piedra todavía tiene 3 libertades así que no es posible ponerla en atari inmediatamente, pero utilizando ataris sucesivos podremos lograr capturarla.</li>
      <div id="tableroEjemplo18" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div id="learn-ladders">
      <h1>Persecución: Escaleras</h1>
      <ul>
      <li>La persecución directa es una <em>técnica de captura</em>.</li>
      <li>Consiste en <em>perseguir</em> un grupo mediante la realización de ataris, hasta lograr que choque contra el borde del tablero o contra un grupo propio, produciéndose de esta forma la captura.</li>
      <li>Vemos a continuación un primer ejemplo muy simple y común, que se produce al dejar una piedra en primera línea sin defender.</li>
      <div id="tableroEjemplo19" class="tableroEjemplo"></div>
      <li>A continuación, vemos un ejemplo de lo que se denomina una <em>escalera</em> debido a la forma llena de &quot;escalones&quot; que tiene el grupo que escapa.</li>
      <div id="tableroEjemplo20" class="tableroEjemplo"></div>
      <li>Si en lugar de terminar en el borde del tablero, con la escalera el jugador logra perseguir al grupo que escapa hasta un grupo propio, podrá igualmente producirse la captura, como se ve en el siguiente ejemplo.</li>
      <div id="tableroEjemplo21" class="tableroEjemplo"></div>
      <li>Si en cambio la escalera lleva hasta un grupo del mismo color que el grupo que escapa, la escalera no funcionará, y el resultado final será muy malo porque deja al jugador que perseguía expuesto a muchísimos dobles ataris (marcados con <em>X</em> en el ejemplo). Se dice que la piedra marcada con <em>A</em> en el ejemplo <em>rompe</em> la escalera.</li>
      <div id="tableroEjemplo22" class="tableroEjemplo"></div>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  <div id="learn-immortal">
      <h1>Grupo inmortal</h1>
      <ul>
      <li> En Atari-go (y aún más en go) es importante el concepto de <em>ojo</em>.</li>
      <li> Esencialmente un ojo es un espacio vacío rodeado por un grupo, de manera tal que su rival no puede jugar ahí adentro, pues sería capturado.</li>
      <li> El diagrama muestra tres grupos con ojos, a modo de ejemplo: El grupo negro tiene dos ojos, y los grupos blancos tienen un solo ojo, pero de distintos tamaños: el ojo marcado con triángulos tiene dos intersecciones, y el marcado con un cuadrado solamente una.</li>
      <div id="tableroEjemplo23" class="tableroEjemplo"></div>
      <li> El grupo que tiene un único ojo de una sola intersección puede ser capturado: si bien en la posición anterior no es posible jugar inmediatamente en el ojo, pues sería suicidio, si el rival lo rodea por completo el grupo queda en atari, pues el cuadrado pasa a ser la <strong>única</strong> libertad del grupo, y entonces se puede terminar de capturar jugando en el ojo, como se muestra a continuación.</li>
      <div id="tableroEjemplo24" class="tableroEjemplo"></div>
      <li> Es claro que no será posible capturar de esta forma al grupo negro, pues al tener <strong>dos ojos diferentes</strong>, sería necesario jugar ambos <strong>a la vez</strong> para ejecutar la captura. De esta forma, tanto en Go como en Atari-go, mientras un grupo tenga dos ojos es <strong>inmortal</strong> y no podrá ser capturado.</li>
      <li> A diferencia de lo que ocurre en el juego de Go, en Atari-go no es posible capturar un grupo que tenga un solo ojo, mientras que el tamaño de este ojo sea de <strong>al menos dos intersecciones</strong>. Si negro quisiera capturar el grupo blanco de la esquina del ejemplo anterior, en algún momento se vería forzado a realizar una jugada dentro del ojo, y como eso lo pone en atari, será negro quien será capturado <strong>primero</strong> si lo intenta.</li>
      <div id="tableroEjemplo25" class="tableroEjemplo"></div>
      <li> Es por estos motivos que tanto en Go como en Atari-go, es importante intentar <strong>rodear</strong> espacios vacíos para asegurarlos.</li>
      <li> Los espacios más fáciles de rodear son las esquinas y los bordes, pues como vimos antes, no es fácil para el rival invadir esos espacios sin ser capturado pues hay muy pocas libertades en esquinas y bordes.</li>
      </ul>
      <p><a href="#atariBotHeaderDiv">Jugar con AtariBot</a></p>
  </div>
  
  <script>

var BOARD_SIZE = 9;
var BOARD_X_START = 40;
var BOARD_Y_START = 40;
var BOARD_X_CELL = 52;
var BOARD_Y_CELL = 52;

var EMPTY = 0;
var BLACK = 1;
var WHITE = 2;
var KOBAN = 3;

var currentPlayer = BLACK;
var globalBoard = []; 
for (var i = 0; i < BOARD_SIZE; i++) {
    globalBoard.push([]);
    for (var j = 0; j < BOARD_SIZE; j++)
        globalBoard[i].push(EMPTY);
}

function boardCopy(boardToCopy) {
    var ret = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        ret.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            ret[i].push(boardToCopy[i][j]);
    }
    return ret;
}

var boardHistory = [boardCopy(globalBoard)];
var moveHistory = [];
var humanPlayer = BLACK;
var engineStrength;

function toLetter(index) {
    return String.fromCharCode('a'.charCodeAt(0) + index);
}

function getSgfString() {
    var ret = "(;SZ[" + BOARD_SIZE + "]";
    for (var i = 0; i < moveHistory.length; i++) {
        var move = moveHistory[i];
        var colorLetter;
        if (move.color == WHITE)
            colorLetter = 'W';
        else if (move.color == BLACK)
            colorLetter = 'B';
        else
            throw "Assertion error: Invalid COLOR in move " + i + " = " + move;
        ret += ";" + colorLetter + "[" + toLetter(move.x) + toLetter(move.y) + "]";
    }
    ret += ")";
    return ret;
}

var gliftWidget = null;

function drawBoard() {
    //document.getElementById("boardText").innerHTML = getBoardHTML(globalBoard);
    if (gliftWidget !== null)
        gliftWidget.destroy();
    gliftWidget = glift.create({
      divId: "gliftDiv",
      sgfDefaults : {
        sgfString : getSgfString(),
        boardRegion : glift.enums.boardRegions.ALL,
        initialPosition : moveHistory.length,
        widgetType : glift.WidgetType.GAME_VIEWER,
        uiComponents : ["BOARD"]
      },
      display: {
        theme: 'DEPTH',
        goBoardBackground: 'images/purty_wood.png'
      }
    });
}

function cellToChar(cell) {
    if (cell == EMPTY)
        return '.';
    else if (cell == BLACK)
        return 'B';
    else if (cell == WHITE)
        return 'W';
    else if (cell == KOBAN)
        return 'K';
    else
        throw "Assertion: contenido de intersección inválida. " + cell;
}

function getBoardHTML(board) {
    var ret = "";
    for (var i = 0; i < BOARD_SIZE; i++) {
        for (var j = 0; j < BOARD_SIZE; j++)
            ret += cellToChar(board[j][i]);
        ret += "<br>";
    }
    return ret;
}

function alertUser(title, message) {
    swal({title : title, text : message});
}

var dx = [0,0,1,-1];
var dy = [1,-1,0,0];

var dfsStatus;
var dfsColor;
var dfsMark;
var dfsBoard;

function clearDfsStatus() {
    dfsStatus = []; 
    for (var i = 0; i < BOARD_SIZE; i++) {
        dfsStatus.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            dfsStatus[i].push(0);
    }
}

function inRange(x,y) {
    return 0 <= x && x < BOARD_SIZE && 0 <= y && y < BOARD_SIZE;
}

function libertyDfs(x,y) {
    dfsStatus[x][y] = dfsMark;
    var liberties = 0;
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && dfsStatus[nx][ny] != dfsMark) {
            if (dfsBoard[nx][ny] == EMPTY)
            {
                liberties++;
                dfsStatus[nx][ny] = dfsMark;
            }
            else if (dfsBoard[nx][ny] == dfsColor)
                liberties += libertyDfs(nx,ny);
        }
    }
    return liberties;
}

function otherPlayer(player) {
    if (player === undefined)
        throw "Assertion: hay que pasarle parametro a otherPlayer!";
    if (player == BLACK)
        return WHITE;
    else if (player == WHITE)
        return BLACK;
    else
        throw "Assertion: el jugador solo puede ser blanco o negro! Es en su lugar " + player;
}

function move(board, player, x,y) {
    if (!inRange(x,y))
        return {"status" : "OUT_OF_RANGE"};
    if (board[x][y] == KOBAN)
        return {"status" :  "No se puede jugar en esa intersección debido a la regla del Ko: se repetiría la posición del tablero."};
    if (board[x][y] != EMPTY)
        return {"status" : "Solamente se puede jugar en una intersección vacía del tablero."};
    
    // Clear the koban
    var kobanX = null, kobanY = null;
    for (var i = 0; i < BOARD_SIZE; i++)
    for (var j = 0; j < BOARD_SIZE; j++)
        if (board[i][j] == KOBAN)
        {
            board[i][j] = EMPTY;
            kobanX = i;
            kobanY = j;
        }
    
    clearDfsStatus();
    
    var dirAtari = [false, false, false, false];
    var atari = [false, false, false, false];
    var playerSafe = false;
    
    var moveWasAtari = false;
    
    for (var dir = 0; dir < 4; dir++) {
        var nx = x + dx[dir];
        var ny = y + dy[dir];
        if (inRange(nx,ny) && board[nx][ny] == EMPTY)
            playerSafe = true;
        if (inRange(nx,ny) && dfsStatus[nx][ny] == 0 && board[nx][ny] != EMPTY) {
            dfsColor = board[nx][ny];
            dfsMark = dir+1;
            dfsBoard = board;
            var gl = libertyDfs(nx,ny);
            if (gl == 1) {
                dirAtari[dir] = true;
                atari[dfsColor] = true;
            }
            else if (dfsColor == player)
                playerSafe = true;
            if (gl == 2 && dfsColor != player)
                moveWasAtari = true;
        }
    }
    
    if (!playerSafe && !atari[otherPlayer(player)])
    {
        if (kobanX !== null)
            board[kobanX][kobanY] = KOBAN;
        return {"status" : "No se puede jugar en esa intersección debido a la regla de no suicidio: la jugada crearía un grupo propio sin libertades."};
    }
    
    // The move is valid
    
    board[x][y] = player;
    
    var captures = 0;
    var captureX, captureY;
    if (atari[otherPlayer(player)])
    {
        for (var i = 0; i < BOARD_SIZE; i++)
        for (var j = 0; j < BOARD_SIZE; j++)
            if (dfsStatus[i][j] > 0 && board[i][j] == otherPlayer(player) && dirAtari[dfsStatus[i][j] - 1])
            {
                board[i][j] = EMPTY;
                captureX = i;
                captureY = j;
                captures++;
            }
    }

    if (captures == 1) {
        // Check for lone stone
        var loneStone = true;
        for (var dir = 0; dir < 4; dir++) {
            var nx = x + dx[dir];
            var ny = y + dy[dir];
            if (inRange(nx,ny) && (nx != captureX || ny != captureY) && (board[nx][ny] != otherPlayer(player)))
                loneStone = false;
        }
        if (loneStone)
            board[captureX][captureY] = KOBAN;
    }
    
    return {"status" : "OK", "board" : board, "captures" : captures, "atari" : moveWasAtari};
}

function resetGame() {
    disableUndo();
    currentPlayer = BLACK;
    humanPlayer = otherPlayer(humanPlayer);
    globalBoard = [];
    for (var i = 0; i < BOARD_SIZE; i++) {
        globalBoard.push([]);
        for (var j = 0; j < BOARD_SIZE; j++)
            globalBoard[i].push(EMPTY);
    }
    boardHistory = [boardCopy(globalBoard)];
    moveHistory = [];
    if (currentPlayer != humanPlayer)
        setTimeout(makeAIMove, 100);
}

function showMessageFunction(humanWins) {
    var message;
    if (humanWins) {
        title   = "¡VICTORIA!";
        message = "Ha derrotado a AtariBot";
    }
    else {
        title = "DERROTA :(";
        message = "Intente nuevamente, es una simple cuestión de práctica";
    }
    return function() {
        alertUser(title, message);
        resetGame();
        drawBoard();
    };
}

function noLegalMove(board, player) {
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) 
        if (board[i][j] == EMPTY) {
            var moveResult = move(boardCopy(board), player, i,j);
            if (moveResult["status"] == "OK")
                return false;
        }
    return true;
}

function makeMove(x,y) {
    var moveResult = move(globalBoard, currentPlayer, x,y);
    if (moveResult["status"] == "OK") {
        boardHistory.push(boardCopy(globalBoard));
        moveHistory.push({"color" : currentPlayer, "x" : x, "y" : y});
        if (moveResult["captures"] > 0 || noLegalMove(globalBoard, otherPlayer(currentPlayer)))
            setTimeout(showMessageFunction(currentPlayer == humanPlayer) , 100);
        else {
            currentPlayer = otherPlayer(currentPlayer);
            if (currentPlayer != humanPlayer) {
                setTimeout(makeAIMove, 100);
                disableUndo();
            }
        }
    }
    else if (moveResult["status"] != "OUT_OF_RANGE")
        alertUser("Jugada inválida", moveResult["status"]);
}

var gliftDiv = document.getElementById("gliftDiv");

function playerSign(player) {
    if (player == BLACK)
        return 1.0;
    else
        return -1.0;
}

var MONTECARLO_PLAYOUTS;

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

var allBoardMoves = [];
for (var i =0; i< BOARD_SIZE; i++)
for (var j =0; j< BOARD_SIZE; j++)
    allBoardMoves.push({"x" : i, "y" : j});

var MAX_MONTECARLO_DEPTH = 10;

function montecarloPlayout(board, player) {
    // initial board has no good atari for us to win immediately
    board = boardCopy(board);
    var montecarloLength = 0;
    while (true) {
        montecarloLength++;
        if (montecarloLength > MAX_MONTECARLO_DEPTH) {
            // Liberty count
            
            var allBlackLiberties = [];
            var allWhiteLiberties = [];
            var markId = 0;
            
            clearDfsStatus();
            for (var i =0; i< BOARD_SIZE; i++)
            for (var j =0; j< BOARD_SIZE; j++) 
            if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
                dfsColor = board[i][j];
                dfsMark = markId;
                dfsBoard = board;
                var gl = libertyDfs(i,j);
                if (board[i][j] == WHITE)
                    allWhiteLiberties.push(gl);
                else
                    allBlackLiberties.push(gl);
                markId++;
            }
            
            allBlackLiberties.sort();
            allWhiteLiberties.sort();
            
            var blackLiberties = 0;
            var w = 1.0;
            for (var i = allBlackLiberties.length - 1; i >=0; i--) {
                blackLiberties += allBlackLiberties[i] * w;
                w /= 2.0;
            }
            
            var whiteLiberties = 0;
            w = 1.0;
            for (var i = allWhiteLiberties.length - 1; i >=0; i--) {
                whiteLiberties += allWhiteLiberties[i] * w;
                w /= 2.0;
            }
            
            var totalLiberties = blackLiberties + whiteLiberties;
            return (playerSign(BLACK) * blackLiberties + playerSign(WHITE) * whiteLiberties) / (3*totalLiberties);
        }
        // Check atari situation
        clearDfsStatus();
        var atari = false;
        var atariX = null;
        var atariY = null;
        var movesForAtari = [];
        var groupId = 0;
        
        for (var i =0; i< BOARD_SIZE; i++)
        for (var j =0; j< BOARD_SIZE; j++) 
        if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
            groupId++;
            dfsColor = board[i][j];
            dfsMark = groupId;
            dfsBoard = board;
            var gl = libertyDfs(i,j);
            if (gl == 1) {
                if (dfsColor == otherPlayer(player)) {
                    return playerSign(player);
                }
                if (!atari) {
                    atari = true;
                    for (var i2 =0; i2< BOARD_SIZE; i2++)
                    for (var j2 =0; j2< BOARD_SIZE; j2++)
                    if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark) {
                        atariX = i2;
                        atariY = j2;
                    }
                }
            }
            else if (gl == 2) {
                for (var i2 =0; i2< BOARD_SIZE; i2++)
                for (var j2 =0; j2< BOARD_SIZE; j2++)
                if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark)
                    movesForAtari.push({"x" : i2, "y" : j2});
            }
        }
        if (atariX !== null) {
            var moveResult = move(board, player, atariX,atariY);
            if (moveResult["status"] != "OK")
                return -playerSign(player);
        }
        else {
            var movesToConsider = [[],allBoardMoves];
            var searchForMove = true;
            if (movesForAtari.length > 0 && Math.random() > 0.1)
                movesToConsider[0] = movesForAtari;
            // Choose random move
            var moveFound = false;
            for (var moveArrayIndex =0; moveArrayIndex < 2; moveArrayIndex++) {
              shuffleArray(movesToConsider[moveArrayIndex]);
              for (var index =0; index < movesToConsider[moveArrayIndex].length; index++) {
                
                var i = movesToConsider[moveArrayIndex][index].x;
                var j = movesToConsider[moveArrayIndex][index].y;
                if (board[i][j] != EMPTY) continue;
                
                // Apply heuristics for "acceptable move"
                                
                var farAway = true;
                var FAR_DIST = 2;
        outerFarAway:
                for (var nx = i-FAR_DIST; nx <= i+FAR_DIST; nx++)
                for (var ny = j-(FAR_DIST - Math.abs(nx-i)); ny <= j+(FAR_DIST - Math.abs(nx-i)); ny++) 
                if (inRange(nx,ny) && board[nx][ny] == player)
                {
                    farAway = false;
                    break outerFarAway;
                }
                if (farAway)
                    continue; // Never play too far away from friendly stones
                
                var loneStone = true;
        outerLoneStone: 
                for (var nx = i-1; nx <= i+1; nx++)
                for (var ny = j-1; ny <= j+1; ny++)
                if (inRange(nx,ny) && board[nx][ny] == player)
                {
                    loneStone = false;
                    break outerLoneStone;
                }
                var noEnemyNear = true;
        enemyNearLoop: 
                for (var nx = i-1; nx <= i+1; nx++)
                for (var ny = j-1; ny <= j+1; ny++)
                if (inRange(nx,ny) && board[nx][ny] == otherPlayer(player))
                {
                    noEnemyNear = false;
                    break enemyNearLoop;
                }
                if ((loneStone || noEnemyNear) && (i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1))
                    continue; // Never play on a border, unless there is a friendly stone in the immediate vicinity
                if (loneStone) {
                    var stoneLiberties = 0;
                    var enemyLiberties = 0;
                    for (var dir = 0; dir < 4; dir++) {
                        var nx = i + dx[dir];
                        var ny = j + dy[dir];
                        if (inRange(nx,ny)) {
                            if (board[nx][ny] == EMPTY)
                                stoneLiberties++;
                            else if (board[nx][ny] == otherPlayer(player)) {
                                var thisEnemyLiberties = 0;
                                for (var dir2 = 0; dir2 < 4; dir2++) {
                                    var nx2 = nx + dx[dir];
                                    var ny2 = ny + dy[dir];
                                    if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                        thisEnemyLiberties++;
                                }
                                if (thisEnemyLiberties > enemyLiberties)
                                    enemyLiberties = thisEnemyLiberties;
                            }
                        }
                    }
                    if (stoneLiberties < 2)
                        continue; // Illegal or self-atari
                    if (stoneLiberties < enemyLiberties)
                        continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
                }
                
                var moveResult = move(board, player, i,j);
                if (moveResult["status"] == "OK") {
                    moveFound = true;
                    break;
                }
            }}
            if (!moveFound)
                return -playerSign(player);
        }
        player = otherPlayer(player);
    }
}


var FULL_ATARI_MINIMAX_EXPLORATION_PLIES;
var NORMAL_ATARI_MINIMAX_EXPLORATION_PLIES;
var SETTING_MINIMAX_EXPLORATION_PLIES;
var ATARI_MINIMAX_EXPLORATION_PLIES;
var MINIMAX_EXPLORATION_PLIES;


function recursiveMinimax(board, player, plies, atariPlies, atariPlayer) {
    board = boardCopy(board);
    
    // Check atari situation
    var keepMakingForcedMoves = true;
    while (keepMakingForcedMoves) {
        keepMakingForcedMoves = false;
        clearDfsStatus();
        var atariX = null;
        var atariY = null;
        var groupId = 0;
        
        for (var i =0; i< BOARD_SIZE; i++)
        for (var j =0; j< BOARD_SIZE; j++) 
        if (dfsStatus[i][j] == 0 && board[i][j] != EMPTY) {
            groupId++;
            dfsColor = board[i][j];
            dfsMark = groupId;
            dfsBoard = board;
            if (libertyDfs(i,j) == 1) {
                if (dfsColor == otherPlayer(player))
                    return playerSign(player);
                if (atariX === null) {
                    for (var i2 =0; i2< BOARD_SIZE; i2++)
                    for (var j2 =0; j2< BOARD_SIZE; j2++)
                    if (board[i2][j2] == EMPTY && dfsStatus[i2][j2] == dfsMark) {
                        atariX = i2;
                        atariY = j2;
                    }
                }
            }
        }
        if (atariX !== null) {
            var moveResult = move(board, player, atariX,atariY);
            if (moveResult["status"] != "OK")
                return -playerSign(player);
            player = otherPlayer(player);
            keepMakingForcedMoves = true;
        }
    }
    
    // Normal search (counts as a ply)
    
    var atariChildren = [];
    var normalChildren = [];
    
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) 
        if (board[i][j] == EMPTY) {
            
            // Do not read "lone" moves
                var loneStone = true;
        outerLoneStone: 
                for (var nx = i-1; nx <= i+1; nx++)
                for (var ny = j-1; ny <= j+1; ny++)
                if (inRange(nx,ny) && board[nx][ny] != EMPTY)
                {
                    loneStone = false;
                    break outerLoneStone;
                }
                if (loneStone)
                    continue;
            
            var moveResult = move(board, player, i,j);
            if (moveResult["status"] == "OK") {
                if (moveResult["captures"] > 0)
                    return playerSign(player);
                if (atariPlayer == player && moveResult["atari"])
                    atariChildren.push({"x" : i, "y" : j});
                else
                    normalChildren.push({"x" : i, "y" : j});
                board[i][j] = EMPTY;
            }
        }
    
    var bestResultSoFar = -playerSign(player);
    
    var newPlies = plies * normalChildren.length;
    var newAtariPlies = atariPlies * atariChildren.length;
    
    if (newPlies <= MINIMAX_EXPLORATION_PLIES) {
        for (var index = 0; index < normalChildren.length; index++) {
            var i = normalChildren[index].x;
            var j = normalChildren[index].y;
            
            var moveResult = move(board, player, i,j);
            if (moveResult["status"] == "OK") {
                childValue = recursiveMinimax(board, otherPlayer(player), newPlies, atariPlies, atariPlayer);
                if (childValue == playerSign(player))
                    return childValue;
                else if (childValue == 0.0)
                    bestResultSoFar = childValue;
                board[i][j] = EMPTY;
            }
        }
    }
    else
        bestResultSoFar = 0.0;
    
    if (newAtariPlies <= ATARI_MINIMAX_EXPLORATION_PLIES) {
        for (var index = 0; index < atariChildren.length; index++) {
            var i = atariChildren[index].x;
            var j = atariChildren[index].y;
            
            var moveResult = move(board, player, i,j);
            if (moveResult["status"] == "OK") {
                childValue = recursiveMinimax(board, otherPlayer(player), plies, newAtariPlies, atariPlayer);
                if (childValue == playerSign(player))
                    return childValue;
                else if (childValue == 0.0)
                    bestResultSoFar = childValue;
                board[i][j] = EMPTY;
            }
        }
    }
    else
        bestResultSoFar = 0.0;
    
    return bestResultSoFar;

}

function signo(x) {
    if (x > 0) return 1;
    else if (x < 0) return -1;
    else return 0;
}

function getAtariGoAIMove(board, player, continuation) {
    if (boardHistory.length < 3) {
        var px = null, py = null;
        for (var i =0; i < BOARD_SIZE; i++) 
        for (var j =0; j < BOARD_SIZE; j++) 
        if ((i == 0 || j == 0 || i == BOARD_SIZE-1 || j == BOARD_SIZE-1) && board[i][j] == otherPlayer(player))
        {
            px = i;
            py = j;
        }
        
        var i,j;
        if (px === null) {
            i = 1 + Math.floor(Math.random() * 6)
            j = 2 + Math.floor(Math.random() * 5)
        }
        else {
            i = px + signo(4-px);
            j = py + signo(4-py);
        }
        var moveResult = move(boardCopy(board), player, i,j);
        return continuation({"x" : i, "y" : j, "newBoard" : moveResult["board"]});
    }
        
    var validMoves = [];
    var minimaxMoves = [];
    var borderMoves = [];
    
    for (var i =0; i< BOARD_SIZE; i++)
    for (var j =0; j< BOARD_SIZE; j++) 
    if (board[i][j] == EMPTY) {
        var moveResult = move(boardCopy(board), player, i,j);
        var moveDescription = {"x" : i, "y" : j, "newBoard" : moveResult["board"]};
        if (moveResult["status"] == "OK") {
            var thisMove = {"x" : i, "y" : j, "result" : moveResult, "description" : moveDescription};
            validMoves.push(thisMove);
            if (moveResult["captures"] > 0)
                return continuation(moveDescription);
                
            var stoneIsSoLonely = true;
            for (var nx = i-1; nx <= i+1; nx++)
            for (var ny = j-1; ny <= j+1; ny++)
            if (inRange(nx,ny) && board[nx][ny] != EMPTY)
                stoneIsSoLonely = false;
            
            if (!stoneIsSoLonely) {
                
                    var loneStone = true;
            outerLoneStone2: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        loneStone = false;
                        break outerLoneStone2;
                    }
                    var noEnemyNear = true;
            enemyNearLoop: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == otherPlayer(player))
                    {
                        noEnemyNear = false;
                        break enemyNearLoop;
                    }
                    
                if (! ((loneStone || noEnemyNear) && (i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1)))
                    minimaxMoves.push(thisMove);
                else
                    borderMoves.push(thisMove);
            }
                
        }
    }
    
    var okMoves = [];
    var afterMinimax;
    
    // This is just a loop:
    //    for (var index =0; index < minimaxMoves.length; index++)
    // Divided step by step using setTimeout so that the browser is not blocked (at least not too much)
    var minimaxLoopStep = function(moveIndex) {
        document.getElementById("percentageIndicator").innerHTML = "Fase 1: " + Math.floor(100 * ((moveIndex+1) / minimaxMoves.length)) + "%";
        for (var dummyVar = 0; dummyVar < 1; dummyVar++) { // So that we can use continue
            var i = minimaxMoves[moveIndex].x;
            var j = minimaxMoves[moveIndex].y;
            
            var moveResult = minimaxMoves[moveIndex].result;
            var moveDescription = minimaxMoves[moveIndex].description;
            
            MINIMAX_EXPLORATION_PLIES = 0;
            ATARI_MINIMAX_EXPLORATION_PLIES = FULL_ATARI_MINIMAX_EXPLORATION_PLIES;
            var childResult = recursiveMinimax(moveResult["board"], otherPlayer(player),1 , 1, player);
            if (childResult == playerSign(player))
                return continuation(moveDescription);
            if (childResult == -playerSign(player))
                continue;
            
            childResult = recursiveMinimax(moveResult["board"], otherPlayer(player), 1, 1, otherPlayer(player));
            if (childResult == playerSign(player))
                throw "IMPOSSIBLE!!!!! NO TENIA QUE SER";
            if (childResult == -playerSign(player))
                continue;
            
            MINIMAX_EXPLORATION_PLIES = SETTING_MINIMAX_EXPLORATION_PLIES;
            ATARI_MINIMAX_EXPLORATION_PLIES = NORMAL_ATARI_MINIMAX_EXPLORATION_PLIES;
            var childResult = recursiveMinimax(moveResult["board"], otherPlayer(player),1 , 1, player);
            if (childResult == playerSign(player))
                return continuation(moveDescription);
            if (childResult == -playerSign(player))
                continue;
            
            childResult = recursiveMinimax(moveResult["board"], otherPlayer(player), 1, 1, otherPlayer(player));
            if (childResult == playerSign(player))
                throw "IMPOSSIBLE!!!!! NO TENIA QUE SER";
            if (childResult == -playerSign(player))
                continue;
                
            okMoves.push({"x" : i, "y" : j, "result" : moveResult, "description" : moveDescription});
        }
        
        moveIndex++;
        if (moveIndex < minimaxMoves.length)
            setTimeout(function() {minimaxLoopStep(moveIndex);}, 0);
        else
            return afterMinimax();
    };
    
    afterMinimax = function() {
        for (var moveIndex = 0; moveIndex < borderMoves.length; moveIndex++)
            okMoves.push(borderMoves[moveIndex]);
        if (okMoves.length == 0)
            okMoves = validMoves;
            
        var bestMove = null, bestScore = null;
        var bestBorderMove = null, bestBorderMoveScore = null;
        
        var finalFunctionCheck = function () {
            if (bestMove === null) {
                if (bestBorderMove === null)
                    return continuation(validMoves[Math.floor(Math.random() * validMoves.length)]);
                else
                    return continuation(bestBorderMove);
            }
            else
                return continuation(bestMove);
        };
        
        var secondPartForLoop = function(moveIndex) {
            document.getElementById("percentageIndicator").innerHTML = "Fase 2: " + Math.floor(100 * ((moveIndex+1) / okMoves.length)) + "%";
            for (var dummyVar = 0; dummyVar < 1; dummyVar++) { // Single element for, so that we can use "continue" inside it to escape.
                var i = okMoves[moveIndex].x;
                var j = okMoves[moveIndex].y;
                
                {
                    
                    var farFromEnemy = true;
            farFromEnemyLoop: 
                    for (var nx = i-2; nx <= i+2; nx++)
                    for (var ny = j-(2-Math.abs(nx-i)); ny <= j+(2-Math.abs(nx-i)); ny++)
                    if (inRange(nx,ny) && board[nx][ny] == otherPlayer(player))
                    {
                        farFromEnemy = false;
                        break farFromEnemyLoop;
                    }
                    if (!farFromEnemy) {
                        var loneStone = true;
                outerLoneStone1: 
                        for (var nx = i-2; nx <= i+2; nx++)
                        for (var ny = j-(2-Math.abs(nx-i)); ny <= j+(2-Math.abs(nx-i)); ny++)
                        if (inRange(nx,ny) && board[nx][ny] == player)
                        {
                            loneStone = false;
                            break outerLoneStone1;
                        }
                        if (loneStone)
                            continue;
                    }
                }

                var borderHeuristicExcluded = false;

                // Apply heuristics for "acceptable move"
                                                        
                    var loneStone = true;
            outerLoneStone2: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == player)
                    {
                        loneStone = false;
                        break outerLoneStone2;
                    }
                    var noEnemyNear = true;
            enemyNearLoop: 
                    for (var nx = i-1; nx <= i+1; nx++)
                    for (var ny = j-1; ny <= j+1; ny++)
                    if (inRange(nx,ny) && board[nx][ny] == otherPlayer(player))
                    {
                        noEnemyNear = false;
                        break enemyNearLoop;
                    }
                    if ((loneStone || noEnemyNear) && (i == 0 || i == BOARD_SIZE-1 || j == 0 || j == BOARD_SIZE-1))
                        borderHeuristicExcluded = true; // Never play on a border, unless there is a friendly stone in the immediate vicinity
                    if (loneStone) {
                        // No not let the opponent trivially cut us
                        var weCanBeCut = false;
                weCanBeCutLoop:
                        for (var dir = 0; dir < 4; dir++) {
                            var midX = i + dx[dir];
                            var midY = j + dy[dir];
                            var nx = i + 2*dx[dir];
                            var ny = j + 2*dy[dir];
                            if (inRange(nx,ny) && board[nx][ny] == player) {
                                if (board[midX][midY] == EMPTY) {
                                    var ex1 = midX + dy[dir];
                                    var ey1 = midY + dx[dir];
                                    var ex2 = midX - dy[dir];
                                    var ey2 = midY - dx[dir];
                                    if (inRange(ex1, ey1) && board[ex1][ey1] == otherPlayer(player) &&
                                        inRange(ex2, ey2) && board[ex2][ey2] == otherPlayer(player)) {
                                            weCanBeCut = true;
                                            break weCanBeCutLoop;
                                    }
                                } else {
                                    // Simply ban the clamp (but atari is of course ok)
                                    var ex1 = midX + dy[dir];
                                    var ey1 = midY + dx[dir];
                                    var ex2 = midX - dy[dir];
                                    var ey2 = midY - dx[dir];
                                    if (inRange(ex1, ey1) && board[ex1][ey1] != player &&
                                        inRange(ex2, ey2) && board[ex2][ey2] != player) {
                                            weCanBeCut = true;
                                            break weCanBeCutLoop;
                                    }
                                }
                            }
                        }
                        if (weCanBeCut)
                            continue;
                        
                        
                        
                        var stoneLiberties = 0;
                        var enemyLiberties = 0;
                        for (var dir = 0; dir < 4; dir++) {
                            var nx = i + dx[dir];
                            var ny = j + dy[dir];
                            if (inRange(nx,ny)) {
                                if (board[nx][ny] == EMPTY)
                                    stoneLiberties++;
                                else if (board[nx][ny] == otherPlayer(player)) {
                                    var thisEnemyLiberties = 0;
                                    for (var dir2 = 0; dir2 < 4; dir2++) {
                                        var nx2 = nx + dx[dir];
                                        var ny2 = ny + dy[dir];
                                        if (inRange(nx2,ny2) && board[nx2][ny2] != player)
                                            thisEnemyLiberties++;
                                    }
                                    if (thisEnemyLiberties > enemyLiberties)
                                        enemyLiberties = thisEnemyLiberties;
                                }
                            }
                        }
                        if (stoneLiberties < 2)
                            continue; // Illegal or self-atari
                        if (stoneLiberties < enemyLiberties)
                            continue; // Never play a lone stone having fewer liberties or friends than adjacent enemy stones
                    }

                var moveResult = okMoves[moveIndex].result;
                var moveDescription = okMoves[moveIndex].description;
                
                var moveScore = 0.0;
                for (var t = 0; t < MONTECARLO_PLAYOUTS; t++)
                    moveScore += montecarloPlayout(moveResult["board"], otherPlayer(player));
                moveScore *= playerSign(player);
                if (!borderHeuristicExcluded && (bestScore === null || moveScore > bestScore)) {
                    bestScore = moveScore;
                    bestMove = moveDescription;
                }
                if (bestBorderMove === null || moveScore > bestBorderMoveScore) {
                    bestBorderMoveScore = moveScore;
                    bestBorderMove = moveDescription;
                }
            }
            moveIndex++;
            if (moveIndex < okMoves.length)
                setTimeout(function() {secondPartForLoop(moveIndex);}, 0);
            else
                return finalFunctionCheck();
        }
        
        if (0 < okMoves.length)
            setTimeout(function() {secondPartForLoop(0);}, 0);
        else {
            return finalFunctionCheck();
        }
    };
    
    setTimeout(function (){ minimaxLoopStep(0);}, 0);
}

function makeAIMove() {
    document.getElementById("atariGoHeader").innerHTML += " [ buscando jugada... ]";
    setTimeout(function () {
        getAtariGoAIMove(globalBoard, currentPlayer, function(aiMove) {
            makeMove(aiMove.x,aiMove.y);
            drawBoard();
            document.getElementById("atariGoHeader").innerHTML = "AtariBot: Fuerza " + engineStrength;
            document.getElementById("percentageIndicator").innerHTML = "";
            if (boardHistory.length > 2)
                enableUndo();
        });
    }, 100);
}

function fooClick(event) {
    if (currentPlayer == humanPlayer) {
        var x = event.pageX - gliftDiv.offsetLeft;
        var y = event.pageY - gliftDiv.offsetTop;
        var moveX = Math.round((x - BOARD_X_START) / BOARD_X_CELL);
        var moveY = Math.round((y - BOARD_Y_START) / BOARD_Y_CELL);
        makeMove(moveX, moveY);
        drawBoard();
    }
}

gliftDiv.addEventListener("click", fooClick);
drawBoard();

function setStrength(strength, playouts, plies, atariPlies, atariFullPlies) {
    return function() {
        engineStrength = strength;
        MONTECARLO_PLAYOUTS = playouts;
        SETTING_MINIMAX_EXPLORATION_PLIES = plies;
        NORMAL_ATARI_MINIMAX_EXPLORATION_PLIES = atariPlies;
        FULL_ATARI_MINIMAX_EXPLORATION_PLIES = atariFullPlies;
        document.getElementById("atariGoHeader").innerHTML = "AtariBot: Fuerza " + strength;
    };
}

document.getElementById("buttonStrength1").onclick = setStrength(1,50  ,100 ,4 , 100);
document.getElementById("buttonStrength2").onclick = setStrength(2,100 ,150 ,6 , 1000 );
document.getElementById("buttonStrength3").onclick = setStrength(3,200 ,200 ,8 , 10000 );
document.getElementById("buttonStrength4").onclick = setStrength(4,400 ,300 ,12, 100000 );
document.getElementById("buttonStrength5").onclick = setStrength(5,800 ,400 ,16, 2000000 );
document.getElementById("buttonStrength6").onclick = setStrength(6,1500,800 ,20, 2000000 );
document.getElementById("buttonStrength7").onclick = setStrength(7,2500,1200,24, 2000000 );
document.getElementById("buttonStrength8").onclick = setStrength(8,4000,1500,28, 2000000 );
document.getElementById("buttonStrength9").onclick = setStrength(9,5000,2500,32, 2000000);

document.getElementById("buttonStrength1").onclick();

disableUndo();

function enableUndo() {
    document.getElementById("undoButton").disabled = false;
}

function disableUndo() {
    document.getElementById("undoButton").disabled = true;
}

document.getElementById("undoButton").onclick = function () {
    if (boardHistory.length < 3)
        throw "Impossible!! boardHistory.length should be >= 3";
    boardHistory.pop();
    moveHistory.pop();
    boardHistory.pop();
    moveHistory.pop();
    globalBoard = boardCopy(boardHistory[boardHistory.length-1]);
    drawBoard();
    if (boardHistory.length < 3)
        disableUndo();
};

/*
gliftWidget = glift.create({
      divId: "gliftDiv",
      sgfDefaults : {
        sgfString : getSgfString(),
        boardRegion : glift.enums.boardRegions.ALL,
        initialPosition : moveHistory.length,
        widgetType : glift.WidgetType.GAME_VIEWER,
        uiComponents : ["BOARD"]
      },
      display: {
        theme: 'DEPTH',
        goBoardBackground: 'images/purty_wood.png'
      }
    });
*/

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    nextMovesPath: '0:19',
    boardRegion : glift.enums.boardRegions.ALL,
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9];AB[cd];AW[dd];AB[cc];AW[dd];AB[ff];AW[dg])",
    widgetType: 'EXAMPLE',
    initialPosition: 6,
    boardRegion : glift.enums.boardRegions.ALL,
    nextMovesPath: "0:0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo2",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9];AB[cd];AW[dd];AB[cc];AW[dd];AB[ff];AW[dg];AW[ce];AW[be];AB[gf];AB[ge];AB[gd];AB[hd];AB[hc];AW[gc];AW[df];AW[ef];AW[eg];AW[fc];AW[fd];AW[fe];AW[fb];AW[fa]AW[gb]" +
                ";LB[dd:A]MA[gd][hd][hc][ge][gf][ff]CR[gb][fe][fd][fc][fb][fa][gc]TR[cc][cd]SQ[ce][be])",
    widgetType: 'EXAMPLE',
    initialPosition: 23,
    boardRegion : glift.enums.boardRegions.ALL,
    nextMovesPath: "0:0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo3",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9];AB[cd];AW[dd];AB[cc];AW[dd];AB[ff];AW[dg];AW[ce];AW[be];AB[gf];AB[ge];AB[gd];AB[hd];AB[hc];AW[gc];AW[df];AW[ef];AW[eg];AW[fc];AW[fd];AW[fe];AW[fb];AW[fa]AW[gb]" +
                ";MA[fg][gg][hf][he][id][ic]CR[ea][eb][ec][ed][ee][ga]TR[hb])",
    widgetType: 'EXAMPLE',
    initialPosition: 23,
    boardRegion : glift.enums.boardRegions.ALL,
    nextMovesPath: "0:0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo4",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9];B[cd];W[dd];B[cc];W[gd];B[ff];W[dg];)",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo5",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AW[cc]AW[cd]AW[db]AW[ec]AW[ed]AB[dc]AB[dd]" +
                "AW[ga]AW[gb]AW[gc]AW[gd]AW[ge]AW[gf]AW[gg]AW[ha]AW[ia]AW[ib]AW[ic]AW[id]AW[ie]AW[if]AW[ig]"+ 
                "AW[hh]AB[hc][hd][he][hf][hg]AW[ff][fh]AB[fg][ef][eh][dg]" +
                "LB[de:A]MA[dd][dc];W[de]LB[hb:A]MA[hc][hd][he][hf][hg];W[hb]LB[eg:A]MA[fg];W[eg])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo6",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AW[gf][hf][if][eg][fg][gg][eh][ih][hi]AB[hh][hg][ig][gh][gi]LB[ii:A])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo7",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AW[aa][fa][ef]MA[ab][ba][ga][ea][fb][df][ff][eg][ee])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo8",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AW[cc][dc][ec]MA[cb][bc][cd][db][dd][eb][ed][fc]AB[dg][eg][eh]MA[cg][df][dh][ef][ei][fg][fh])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo9",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AW[db][dc][dd][de][df][dg][dh]MA[da][cb][eb][cc][ec][cd][ed][ce][ee][cf][ef][cg][eg][ch][eh][di])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo10",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bg][cg][cf][df][de][ee][ed]MA[ag][bh][bf][ch][ce][dd][dg][ec][ef][fd][fe])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo11",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bb][cb][db][bc][cc][dc][bd][cd][dd][fe][ge][he][ff][hf][fg][gg][hg]MA[cc][gf])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo12",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bb][cb][db][bc][cc][be][ce]AW[ba][aa][ab][ca][da][dc][ac][ad][bd];W[eb];B[cd])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo13",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bb][cb][db][bc][cc][be][ce]AW[ba][aa][ab][ca][da][dc][ac][ad][bd];W[eb];B[ec];W[cd])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo14",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bb][cb][db][ec][fd][ge][he][hd][hc]AW[eb][fb][fc][gc][gd][hb];W[ed];B[fe];W[dc])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo15",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bb][cb][db][ec][fd][ge][he][hd][hc]AW[eb][fb][fc][gc][gd][hb];W[ed];B[dc];W[fe])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo16",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[ed][db][ec][fd][ge][he][hd][hc]AW[dc][eb][fb][fc][gc][gd][hb];W[cb];B[da];W[ca];B[ea];W[fa])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo17",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[fe][db][ec][fd][ge][he][hd][hc]AW[eb][fb][fc][gc][gd][hb]LB[db:A];W[dc];B[ed];W[cb];B[da];W[ea];B[ca];W[ba])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo18",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[ga][hb][hc][hd]AW[ha][ia][ib][ic][id][ie];W[gb];B[fa];W[fb];B[ea];W[eb];B[da];W[db];B[ca];W[cb];B[ba];W[bb];B[aa];W[ab])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo19",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[fa][ga][hb][hc][hd]AW[hf][hg][ha][ia][ib][ic][id][ie][gb];B[fb];W[gc];B[gd];W[fc];B[ec];W[fd];B[fe];W[ed];B[dd];W[ee];B[ef];W[de];B[ce];W[df];B[dg];W[cf];B[bf];W[cg];B[ch];W[bg];B[bh];W[ag];B[af];W[ah];B[ai])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo20",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[bf][bg][bi][fa][ga][hb][hc][hd]AW[hf][hg][ha][ia][ib][ic][id][ie][gb];B[fb];W[gc];B[gd];W[fc];B[ec];W[fd];B[fe];W[ed];B[dd];W[ee];B[ef];W[de];B[ce];W[df];B[dg];W[cf];B[cg])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo21",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[fa][ga][hb][hc][hd]AW[bf][hf][hg][ha][ia][ib][ic][id][ie][gb]LB[bf:A];B[fb];W[gc];B[gd];W[fc];B[ec];W[fd];B[fe];W[ed];B[dd];W[ee];B[ef];W[de];B[ce];W[df];B[dg];W[cf]MA[cd][dc][eb][eg][ff][ge])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo22",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[aa][bb][ac][ca][bc][cb]AW[ha][hb][hc][ic][df][ef][dg][dh][eh][fh][fg]MA[ab][ba]TR[ia][ib]SQ[eg])",
    widgetType: 'EXAMPLE',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD"],
  },
  divId: "tableroEjemplo23",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[aa][bb][ac][ca][bc][cb]AW[ha][hb][hc][ic][df][ef][dg][dh][eh][fh][fg]MA[ab][ba]TR[ia][ib]SQ[eg];B[de];B[ee];B[fe];B[ff];B[gg];B[gh];B[fi];B[ei];B[di];B[ch];B[cg];B[cf];B[eg])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo24",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

glift.create({
  sgf: {
    //url: 'sgf/gogameguru_commentary.sgf',
    sgfString : "(;SZ[9]AB[aa][bb][ac][ca][bc][cb]AW[ha][hb][hc][ic][df][ef][dg][dh][eh][fh][fg]MA[ab][ba]TR[ia][ib]SQ[eg];B[ga];B[gb];B[gc];B[gd];B[hd];B[id];B[ib];W[ia])",
    widgetType: 'GAME_VIEWER',
    initialPosition: 0,
    boardRegion : glift.enums.boardRegions.ALL,
    //nextMovesPath: "0",
    uiComponents : ["BOARD","ICONBAR"],
  },
  divId: "tableroEjemplo25",
  display: {
    theme: 'DEPTH',
    goBoardBackground: 'images/purty_wood.png',
  }
});

  </script>
  
</body>
</html>
